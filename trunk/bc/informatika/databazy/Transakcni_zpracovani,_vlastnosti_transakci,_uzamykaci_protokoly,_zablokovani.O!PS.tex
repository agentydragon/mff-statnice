\subsection{Transakèní zpracování, vlastnosti transakcí, uzamykací protokoly, zablokování}

\begin{e}{Definice}{0}{Transakce}
\emph{Transakce} je jistá posloupnost nebo specifikace posloupnosti akcí práce s databází, jako
jsou ètení, zápis nebo vıpoèet, se kterou se zachází jako s jedním celkem.
\end{e}

Hlavním smyslem pouívání transakcí, tj. \emph{transakèního zpracování}, je
udrení databáze v konzistentním stavu. Jestlie na sobì nìkteré operace závisí,
sdruíme je do jedné transakce a tím zabezpeèíme, e budou vykonány buï
všechny, nebo ádná. Databáze tak pøed i po vykonání transakce bude v
konzistentním stavu. Aby se uivateli transakce jevila jako jedna atomická
operace, je nutné zavést pøíkazy COMMIT a ROLLBACK. První z nich signalizuje
databázi úspìšnost provedení transakce, tj. veškeré zmìny v databázi se stanou
trvalımi a jsou zviditelnìny pro ostatní transakce, druhı pøíkaz signalizuje
opak, tj. databáze musí bıt uvedena do pùvodního stavu.

Tyto pøíkazy vìtšinou není nutné volat explicitnì, napø. pøíkaz COMMIT je vyvolán po
normálním ukonèení programu realizujícího transakci. Pøíkaz ROLLBACK pro svou
funkci vyaduje pouití tzv. \emph{urnálu} (logu) na nìjakém stabilním
pamìovém médiu. urnál obsahuje historii všech zmìn databáze v jisté èasové
periodì.

Jednoduchá transakce vypadá vìtšinou takto:
\begin{penumerate}
  \item Zaèátek transakce,
  \item provedení nìkolika dotazù -- ètení a zápisù (ádné zmìny v databázi nejsou zatím vidìt pro
  okolní svìt),
  \item Potvrzení (pøíkaz COMMIT) transakce (pokud se transakce povedla, zmìny
  v databázi se stanou viditelné).
\end{penumerate}
Pokud nìjakı z provedenıch dotazù sele, systém by mìl celou transakci zrušit a
vrátit databázi do stavu v jakém byla pøed zahájením transakce (operace ROLLBACK).

Transakèní zpracování je také ochrana databáze pøed hardwarovımi nebo
softwarovımi chybami, které mohou zanechat databázi po èásteèném zpracování
transakce v nekonzistentním stavu. Pokud poèítaè sele uprostøed provádìní
nìkteré transakce, transakèní zpracování zaruèí, e všechny operace z
nepotvrzenıch (\uv{uncommitted}) transakcí budou zrušeny. 

\subsubsection*{Vlastnosti transakcí}

Podívejme se nyní na vlastnosti poadované po transakcích. Obvykle se pouívá
zkratka prvních písmen anglickıch názvù vlastností \textbf{ACID}~-- atomicity,
consistency, isolation (independence), durability. 
\begin{description}
  \item[atomicita] -- transakce se tváøí jako jeden celek, musí buï probìhnout
  celá, nebo vùbec ne.
  \item[konzistence] -- transakce transformuje databázi z jednoho konzistentního
  stavu do jiného konzistentního stavu.
  \item[nezávislost] -- transakce jsou nezávislé, tj. dílèí efekty transakce
  nejsou viditelné jinım transakcím.
  \item[trvanlivost] -- efekty úspìšnì ukonèené (potvrzené,\uv{commited})
  transakce jsou nevratnì uloeny do databáze a nemohou bıt zrušeny.
\end{description}

Transakce mohou bıt v uivatelskıch programech provádìny paralelnì (spíše
zdánlivì paralelnì, stejnì jako je paralelismus multitaskingu na jednoprocesorovıch
strojích jen zdánlivı, zajistí to ale monost paralelizace \uv{nedatabázovıch} 
akcí a pomalé transakce nebrzdí rychlé). Je
zøejmé, e posloupnost transakcí mùe bıt zpracována paralelnì rùznım zpùsobem.
Kadá transakce se skládá z nìkolika akcí. Stanovené poøadí provádìní akcí
více transakcí v èase nazveme \textbf{rozvrhem}.

Rozvrh, kterı splòuje následující podmínky, budeme nazıvat \textbf{legální}:
\begin{pitemize}
  \item Objekt je nutné mít uzamknutı, pokud k nìmu chce transakce pøistupovat.
  \item Transakce se nebude pokoušet uzamknout objekt ji uzamknutı jinou
  transakcí (nebo musí poèkat, ne bude objekt odemknut).
\end{pitemize}

Dùleitımi pojmy pro paralelní zpracování jsou sériovost èi uspoøádatelnost.
\textbf{Sériové rozvrhy} zachovávají operace kadé transakce pohromadì (a 
provádí se jen jedna transakce najednou). Pro $n$
transakcí tedy existuje $n!$ rùznıch sériovıch rozvrhù. Pro získání korektního
vısledku však mùeme pouít i rozvrhu, kde jsou operace rùznıch transakcí
navzájem prokládány.
Pøirozenım poadavkem na korektnost je, aby efekt paralelního zpracování
transakcí byl tı, jako kdyby transakce byly provedeny v nìjakém sériovém rozvrhu.
Pøedpokládáme-li toti, e kadá transakce je korektní program, mìl by vést
vısledek sériového zpracování ke konzistentnímu stavu. O systému zpracování
transakcí, kterı zaruèuje dosaení konzistentního stavu nebo stejného stavu
jako sériové rozvrhy, se øíká, e zaruèuje \textbf{uspoøádatelnost}.

Mohou se vyskytnout problémy, které uspoøádatelnosti zamezují. Ty nazıváme \emph{konflikty}. Plynou z poøadí dvojic akcí rùznıch transakcí na stejném objektu. Existují tøi typy konfliktních situací:
\begin{penumerate}
    \item WRITE-WRITE -- pøepsání nepotvrzenıch dat
    \item READ-WRITE -- neopakovatelné ètení
    \item WRITE-READ -- ètení nepotvrzenıch (\uv{uncommitted}) dat
\end{penumerate}

Øekneme, e rozvrh je \emph{konfliktovì uspoøádatelnı}, je-li konfliktovì ekvivalentní nìjakému sériovému rozvrhu (tedy jsou v nìm stejné, tj. ádné konflikty). Test na konfliktovou uspoøádatelnost se dá provést jako test acykliènosti grafu, ve kterém konfliktní situace pøedstavují hrany a transakce vrcholy. Konfliktová uspoøádatelnost je slabší podmínka ne uspoøádatelnost -- nezohledòuje ROLLBACK (\emph{zotavitelnost} -- zachování konzistence, i kdy kterákoliv transakce sele) a dynamickou povahu databáze (vkládání a mazání objektù). Zotavitelnosti se dá dosáhnout tak, e kadá transakce $T$ je potvrzena a poté, co jsou potvrzeny všechny ostatní transakce, které zmìnily data ètená v $T$. Pokud v zotavitelném rozvrhu dochází ke ètení zmìn pouze potvrzenıch transakcí, nemùe dojít ani k jejich \emph{kaskádovému rušení}.

Pøi zpracování (i uspoøádatelného) rozvrhu mùe dojít k situaci \emph{uváznutí} -- \emph{deadlocku}. To nastane tehdy, pokud jedna transakce $T_1$ èeká na zámek na objekt, kterı má pøidìlenı $T_2$ a naopak. Situaci lze zobecnit i na více transakcí. Uváznutí lze buï pøímo zamezit charakterem rozvrhu, nebo detekovat (hledáním cyklu v grafu èekajících transakcí, tzv. \uv{waits-for} grafu) a jednu z transakcí \uv{zabít} a spustit znova.

\medskip
K zajištìní uspoøádatelnosti a zotavitelnosti a zabezpeèení proti kaskádovım rollbackùm a deadlocku se pouívají rùzná schémata (poadavky na rozvrhy). Jedním z nich jsou uzamykací protokoly.

\subsubsection*{Uzamykací protokoly}

Vytváøení rozvrhù a testování jejich uspoøádatelnosti není pro praxi zøejmì ten
nejvhodnìjší zpùsob. Pokud ale budeme transakce konstruovat podle urèitıch
pravidel, tak za urèitıch pøedpokladù bude kadı jejich rozvrh uspoøádatelnı.
Soustavì takovıch pravidel se øíká \textbf{protokol}.

Nejznámìjší protokoly jsou zaloeny na dynamickém zamykání a odemykání objektù v
databázi. Zamykání (operace LOCK) je akce, kterou vyvolá transakce na objektu,
aby ho chránila pøed pøístupem ostatních transakcí.

\begin{e}{Definice}{0}{Dobøe formovaná transakce}
Transakci nazveme \textbf{dobøe formovanou} pokud podporuje pøirozené poadavky
na transakce:
\begin{penumerate}
  \item transakce zamyká objekt, chce-li k nìmu pøistupovat,
  \item transakce nezamyká objekt, kterı ji je touto transakcí uzamèenı,
  \item transakce neodmyká objekt, kterı není touto transakcí zamèenı,
  \item po ukonèení transakce jsou všechny objekty uzamèené touto transakcí
  odemèeny.
\end{penumerate}
\end{e}

\paragraph{Dvoufázovı protokol (2PL)} -- Dvoufázová transakce v první fázi
zamyká vše co je potøeba a od prvního odemknutí (druhá fáze) ji jen odemyká co
mìla zamèeno (ji ádná operace LOCK). Tedy transakce musí mít všechny objekty
uzamèeny pøedtím, ne nìjakı objekt odemkne. Dá se dokázat, e pokud jsou
všechny transakce v dané mnoinì transakcí dobøe formované a dvoufázové, pak
kadı jejich legální rozvrh je uspoøádatelnı.

Dvoufázovı protokol zajišuje uspoøádatelnost, ale ne zotavitelnost ani
bezpeènost proti kaskádovému rušení transakcí nebo uváznutí.

\paragraph{Striktní dvoufázovı protokol (S2PL)} -- Problémy 2PL jsou nezotavitelnost
a kaskádové rušení transakcí. Tyto nedostatky lze odstranit pomocí striktních
dvoufázovıch protokolù, které uvolòují zámky a po skonèení transakce (COMMIT).
Zøejmá nevıhoda je omezení paralelismu. 2PL navíc stále nevyluèuje monost deadlocku.

\paragraph{Konzervativní dvoufázovı protokol (C2PL)} -- Rozdíl oproti 2PL je
ten, e transakce ádá o všechny své zámky, ještì ne se zaène
vykonávat. To sice vede obèas k zbyteènému zamykání (nevíme co pøesnì budeme
potøebovat, tak radši zamkneme víc), ale staèí to ji k prevenci uváznutí
(deadlocku).

\subsubsection*{\uv{Vylepšení} zamykacích protokolù}

\paragraph{Sdílené a vıluèné zámky} -- Nevıhodou 2PL je, e objekt mùe mít
uzamèenı pouze jedna transakce. Abychom uzamykání provedli preciznìji, je dobré
vzít na vìdomí rozdíl mezi operacemi READ a WRITE. \emph{Vıluènı zámek}
(W\_LOCK) mùe bıt aplikován na objekty jak pro operaci READ tak pro WRITE,
\emph{sdílenı zámek} (R\_LOCK) uzamyká objekt, kterı chceme pouze èíst. Jeden
objekt potom mùe bıt uzamèen sdílenım zámkem více transakcí a zvyšuje se tak
monost paralelního zpracování. Budeme-li s tìmito zámky zacházet stejnì jako u
2PL, opìt máme zaruèenou uspoøádatelnost rozvrhu, ovšem nikoliv absenci uváznutí.


\paragraph{Strukturované uzamykání (multiple granularity)} -- Objekty jsou v
tomto pøípadì chápány hierarchicky dle relace \emph{obsahuje}. Napøíklad
databáze obsahuje soubory, které obsahují stránky a ty zase obsahují jednotlivé
záznamy. Na tuto hierarchii se mùeme dívat jako na strom, ve kterém kadı
vrchol obsahuje své potomky. Kdy transakce zamyká objekt (vrchol) zamyká také
všechny jeho potomky. Protokol se tak snaí minimalizovat poèet zámkù, tím
sníit reii a zvıšit monosti paralelního zpracování.


\subsubsection*{Alternativní protokoly}

\paragraph{Èasová razítka} -- Další z protokolù zaruèující uspoøádatelnost je
vyuití èasovıch razítek. Na zaèátku dostane transakce $T$ \emph{èasové
razítko}~-- $TS(T)$ (èasová razítka jsou unikátní a v èase rostou), abychom vìdìli
poøadí, ve kterém by mìli bıt transakce vykonány. Kadı objekt v databázi má
\emph{ètecí razítko}~-- $RTS(O)$ (read timestamp), které je aktualizováno, kdy je
objekt èten, a \emph{zapisovací razítko}~-- $WTS(O)$ (write timestamp), které je
aktualizováno, kdy nìjaká transakce objekt mìní.

Pokud chce transakce $T$ èíst objekt $O$ mohou nastat dva pøípady:
\begin{pitemize}

  \item $TS(T) < WTS(O)$, tzn. nìkdo zmìnil objekt $O$ potom co byla spuštìna
  transakce $T$. V tomto pøípadì musí bıt transakce zrušena a spouštìna znovu (a
  tedy s jinım èasovım razítkem).

  \item $TS(T) > WTS(O)$, tzn. je bezpeèné objekt èíst. V tomto pøípadì $T$
  pøeète $O$ a $RTS(O)$ je nastaveno na $\max\{TS(T),\ RTS(O)\}$.

\end{pitemize}

Pokud chce transakce $T$ zapisovat do objektu $O$ rozlišujeme pøípady tøi:
\begin{pitemize}

  \item $TS(T) < RTS(O)$, tzn. nìkdo èetl $O$ poté co byla spuštìna $T$ a
  pøedpokládáme, e si poøídil lokální kopii. Nemùeme tedy $O$ zmìnit, protoe
  by lokální kopie pøestala bıt platná a tedy je nutné $T$ zrušit a spustit
  znova.

  \item $TS(T) < WTS(O)$, tzn. nìkdo zmìnil $O$ po startu $T$. V tomto pøípadì
  pøeskoèíme write operaci a pokraèujeme dále normálnì. $T$ nemusí bıt
  restartována.

  \item V ostatních pøípadech $T$ zmìní $O$ a $WTS(O)$ je nastaveno na $TS(T)$.
\end{pitemize}

\paragraph{Optimistické protokoly} -- V situaci kdy se vìtšina transakcí
neovlivòuje, je reie vıše uvedenıch protokolù zbyteènì velká a mùeme pouít
takzvanı optimistickı protokol. V protokolu mùeme rozlišit tøi fáze.
\begin{penumerate}

  \item \textbf{Fáze ètení:} Ètou se objekty z databáze do lokální pamìti a jsou
  na nich provádìny potøebné zmìny.

  \item \textbf{Fáze kontroly:} Po dokonèení všech zmìn v lokální pamìti je
  vyvolán pokus o zapsání vısledkù do databáze. Algoritmus zkontroluje, zda
  nehrozí potenciální kolize s ji potvrzenımi transakcemi, nebo s nìkterımi
  právì probíhajícími. Pokud konflikt existuje, je tøeba spustit algoritmus pro
  øešení kolizí, kterı se je snaí vyøešit. Pokud se mu to nepodaøí, je vyuita
  poslední monost a tou je zrušení a restartování transakce.

  \item \textbf{Fáze zápisu:} Pokud nehrozí ádné konflikty, jsou data z lokální
  pamìti zapsány do databáze a transakce potvrzena.

\end{penumerate}


