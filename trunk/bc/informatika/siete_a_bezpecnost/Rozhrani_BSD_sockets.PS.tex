\subsection{Rozhraní BSD Sockets}

\subsubsection*{Úvod}
\textbf{Berkeley (BSD) sockets} je rozhranie (API) na vyvíjanie aplikácií ktoré pouívajú medziprocesovú komunikáciu (napr. v rámci siete). De facto je to štandardná abstrakcia pre sieové sockety. Primárnym jazykom tohto API je C, pre väèšinu ostatnıch však existujú podobné rozhrania.

BSD sockets je API umoòujúce komunikáciu medzi dvomi hostmi alebo procesmi na jednom poèítaèi, pouívajúc koncepciu internetovıch socketov. Toto rozhranie je implicitné pre TCP/IP a je teda jednou zo základnıch technológií internetu. Programátori môu vyuíva rozhrania socketov na troch úrovniach, najzákladnejšou z nich sú RAW sockety (aj keï túto úroveò sa vyuijú zväèša len na poèítaèoch implementujúcich technológie tıkajúce sa u priamo internetu).

\subsubsection*{Hlavièkové súbory}
Berkeley sockets pouívajú viaceré hlavièkové súbory, okrem iného:
\begin{pitemize}
\item\textbf{sys/socket.h} Core BSD socket functions and data structures.
\item\textbf{netinet/in.h} AF\_INET and AF\_INET6 address families. Widely used on the Internet, these include IP addresses and TCP and UDP port numbers.
\item\textbf{sys/un.h} AF\_UNIX address family. Used for local communication between programs running on the same computer. Not used on networks.
\item\textbf{arpa/inet.h} Functions for manipulating numeric IP addresses.
\item\textbf{netdb.h} Functions for translating protocol names and host names into numeric addresses. Searches local data as well as DNS.
\end{pitemize}

\subsubsection*{TCP}
TCP poskytuje koncept spojenia. Proces vytvorí TCP socket pomocou volania socket() s parametrom PF\_INET(6) a SOCK\_STREAM.

\begin{obecne}{Server}
Vytvorenie jednoduchého TCP servera vyaduje nasledujúce kroky:
\begin{pitemize}
\item Vytvorenie TCP socketu (pomocou volania \emph{socket()})
\item Pripojenie socketu na port, kde bude naèúva (\emph{bind()}; parametrami je sockaddr\_in štruktúra, v ktorej sa nastavuje sin\_family (AF\_INET-IPv4,\\AF\_INET6-IPv6) a sin\_port)
\item Pripravenie socketu na naèúvanie na porte (\emph{listen()}).
\item Akceptovanie príchodzích pripojení pomocou \emph{accept()}. Táto funkcia blokuje volajúceho do príchodu pripojenia a vracia identifikátor príchodzieho spojenia, ktorı sa môe ïalej poui. accept() je hneï moné vola na pôvodnı identifikátor socketu na èakanie na ïalšie spojenia.
\item Komunikácia s klientom pomocou \emph{send()}, \emph{recv()} alebo \emph{read()} a \emph{write()}
\item Keï u socket nie je potrebnı, je moné ho zavrie pomocou \emph{close()}.
\end{pitemize}
\end{obecne}

\begin{obecne}{Klient}
Vytvorenie TCP klienta vyaduje nasledujúce kroky:
\begin{pitemize}
\item Vytvorenie TCP socketu (pomocou volania \emph{socket()})
\item Pripojenie k serveru pomocou \emph{connect()}) (znovu sa pouíva štruktúra sockaddr\_in, vypåòa sa sin\_family, sin\_port (ako pri serveri) + sin\_addr (adresa servera))
\item Komunikácia so serverom pomocou \emph{send()}, \emph{recv()} alebo \emph{read()} a \emph{write()}
\item Keï u socket nie je potrebnı, je moné ho zavrie pomocou \emph{close()}.
\end{pitemize}
\end{obecne}

\subsubsection*{UDP}
UDP je protokol bez spojenia (conectionless) a bez garancie doruèenia správ. UDP balíky môu (okrem správneho poètu/poradia) dorazi mimo poradia, môu by duplikované alebo nedorazi ani raz. Vïaka minimálnym garanciám má UDP oproti TCP ove¾a menšiu réiu. Keïe tento protokol nevytvára spojenia, dáta sa prenášajú v datagramoch.

Adresovací priestor UDP (porty UDP) je úplne nezávislı na priestore portov TCP.

\begin{obecne}{Server}
Keïe sa nevytvárajú spojenia, po vytvorení socketu (ako pri TCP pomocou socket()+bind()) u aplikácia (server) rovno èaká príchodzie datagramy pomocou funkcie \emph{recvfrom()}. Na konci sa socket zatvára pomocou close().
\end{obecne}

\begin{obecne}{Klient}
U klienta je tie oproti spojovanej verzii zjednodušenie - staèí vyrobi socket (pomocou socket()) a potom u iba posiela datagramy pomocou \emph{sendto()}. Na konci sa socket zatvára pomocou close().
\end{obecne}

\subsubsection*{Najdôleitejšie funkcie}

\begin{pitemize}

\item \textbf{int socket(int domain, int type, int protocol)}
	\begin{pitemize}
		\item \emph{domain} (PF\_INET | PF\_INET6)
		\item \emph{type} (SOCK\_STREAM, SOCK\_DGRAM,\\SOCK\_SEQPACKET (spo¾ahlivé zoradené balíky),\\SOCK\_RAW (raw protokoly nad sieovou vrstvou))
		\item \emph{protocol} (väèšinou IPPROTO\_IP, ïalšie sú v netinet/in.h)
	\end{pitemize}

	\item \textbf{struct hostent *gethostbyname(const char *name)\\
	struct hostent *gethostbyaddr(const void *addr, int len, int type)}
	\begin{pitemize}
		\item Vracia pointer na hostent štruktúru, ktorá popisuje internetového hosta zadaného pomocou mena alebo adresy (obsahuje buï informácie od name servera, alebo z lokálneho /etc/hosts súboru)...
	\end{pitemize}

	\item \textbf{int connect(int sockfd, const struct sockaddr *serv\_addr, socklen\_t addrlen)}
	\item \textbf{int bind(int sockfd, struct sockaddr *my\_addr, socklen\_t addrlen)}
	\item \textbf{int listen(int sockfd, int backlog)}
	\begin{pitemize}
		\item \emph{backlog} urèuje maximálne ko¾ko pripojení môe vo fronte èaka na akceptovanie...
	\end{pitemize}

	\item \textbf{int accept(int sockfd, struct sockaddr *cliaddr, socklen\_t *addrlen)}\\
	do \emph{cliaddr} sa vyplnia informácie o klientovi...
\end{pitemize}

\subsubsection*{Blokujúce a neblokujúce volania}
BSD sockety môu fungova v dvoch módoch - blokujúcich a neblokujúcich. V blokujúcom móde funkcie nevrátia riadenie programu, kım nie sú spracované všetky dáta - èo môe spôsobi rôzne problémy (program \uv{zamrzne}, keï socket naèúva; alebo keï socket èaká na dáta, ktoré neprichádzajú). Typicky sa nastavuje neblokujúci mód pomocou \emph{fcntl()} alebo \emph{ioctl()}
