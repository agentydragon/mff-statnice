%&latex
\newpage\subsection{Objektovì orientované programování\footnote{podle zkoušení Burešem a Tùmou}}  

\begin{obecne}{Úèel objektového programování}
In the 1960s, language design was often based on textbook examples of programs, which were generally small (due to the size of a textbook); however, when programs become very large, the focus changes. In small programs, the most common statement is generally the assignment statement; however, in large programs (over 10,000 lines), the most common statement is typically the procedure-call to a subprogram. Ensuring parameters are correctly passed to the correct subprogram becomes a major issue.

Many small programs can be handled by coding a hierarchy of structures; however, in large programs, the organization is more a network of structures, and insistence on hierarchical structuring for data and procedures can produce cumbersome code with large amounts of "tramp data" to handle various options across the entire program.

Although structuring a program into a hierarchy might help to clarify some times of software, even for some special types of large programs, a small change, such as requesting a user-chosen new option (text font-color) could cause a massive ripple-effect with changing multiple subprograms to propagate the new data into the program's hierarchy. The object-oriented approach is allegedly more flexible, by separating a program into a network of subsystems, with each controlling their own data, algorithms, or devices across the entire program, but only accessible by first specifying named access to the subsystem object-class, not just by accidentally coding a similar global variable name. Rather than relying on a structured-programming hierarchy chart, object-oriented programming needs a call-reference index to trace which subsystems or classes are accessed from other locations.
\end{obecne}


\begin{definiceN}{Objektovì orientované programování}
Objektovì orientované programování (zkracováno na OOP, z anglického Object-oriented programming) je metodika vıvoje softwaru. Dá se na nìj nahlédnout jako na kolekci spolupracujících objektù -- v protikladu k tradiènímu pohledu, kdy se za program povauje sled instrukcí pro poèítaè. V OOP je kadı objekt schopnı pøijímat zprávy, zpracovávat data a posílat zprávy jinım objektùm. Na kadı objekt se tak dá nahlíet jako na nezávislı \uv{malı stroj} s vlastní rolí a zodpovìdností. Zjednodušenì øeèeno jde o~dotaení konceptu \emph{data + algoritmy = program}. Data tvoøí s kódem, kterı je spravuje, jeden celek.
Je zaloeno na následujících myšlenkách, koncepci:
\end{definiceN}
\begin{obecne}{Objekty} Jednotlivé prvky modelované reality (jak data, tak související funkènost) jsou v programu seskupeny do entit, nazıvanıch objekty. Objekty si pamatují svùj stav a navenek poskytují operace (pøístupné jako metody pro volání).
\\\\
\textbf{Implementace objektù}
Z hlediska jazyka není velkı rozdíl mezi sloenımi datovımi typy a tøídami. Deklarace tøídy obsahuje, stejnì jako u sloeného dat. typu, datové poloky. Navíc ale obsahuje i deklarace funkcí (metod), které s nimi pracují. Nìkteré funkce mohou mít speciální vlastnosti -- statické, virtuální, konstruktory, destruktory. Navíc vìtšina jazykù pøidává monost oznaèení kterıchkoliv poloek jako veøejné nebo privátní. Tøídy mohou nìkdy (C++, Java) obsahovat i vnoøené datové typy (vıèty, ... ) a dokonce vnoøené tøídy.

Za bìhu je jedna instance tøídy -- objekt reprezentována v pamìti pomocí:
\begin{pitemize}
    \item datovıch poloek (stejnì jako sloenı datovı typ),
    \item skrytıch pomocnıch poloek umoòujících funkci virtuálních metod, vıjimek, RTTI a dìdiènosti (identifikace typu / jeho velikosti apod.)
\end{pitemize}
\end{obecne}

\begin{obecne}{Abstrakce} Programátor, potamo program, kterı vytváøí, mùe abstrahovat od nìkterıch detailù práce jednotlivıch objektù. Kadı objekt pracuje jako èerná skøíòka, která dokáe provádìt urèené èinnosti a komunikovat s okolím, ani by vyadovala znalost zpùsobu, kterım vnitønì pracuje.

\end{obecne}
\begin{obecne}{Zapouzdøení} Zaruèuje, e objekt nemùe pøímo pøistupovat k \uv{vnitønostem} jinıch objektù, co by mohlo vést k nekonzistenci. Kadı objekt navenek zpøístupòuje rozhraní, pomocí kterého (a nijak jinak) se s objektem pracuje.
\\\\
\textbf{Jake ma vyhody OOP proti pouze proceduralnimu programovani} - Zacal jsem zapouzdrenim, kde me vcelku potrapil pure C jazykem jehoz moduly, .h soubory, pouziti staticu, ifdefu a dalsich konstruktu muze slouzit jako slusne zapouzdreni - ukolem bylo rict na konkretnim jazyce co prinasi OOP navic (napr. vetsi granularita oddeleni (Java a viditelnost v Packagi, protected, final...))
\\\\
We use these keywords to specify access levels for member variables, or for member functions (methods).
\begin{pitemize}
    \item \textbf{public} variables, are variables that are visible to all classes.
    \item \textbf{private} variables, are variables that are visible only to the class to which they belong.
    \item \textbf{protected} variables, are variables that are visible only to the class to which they belong, and any subclasses.
\end{pitemize}
\end{obecne}

\begin{obecne}{Skládání}Objekt mùe vyuívat slueb jinıch objektù tak, e je poádá o provedení operace.
\end{obecne}

\begin{obecne}{Tøída}
\emph{Tøída} definuje abstraktní vlastnosti nìjakého objektu, vèetnì obsaenıch dat (atributy, pole (fields) a vlastnosti (properties)) a vìcí, které mùe dìlat (chování, metody a schopnosti (features)). Napøíklad tøída \emph{Dog} by obsahovala vìci spoloèné pro všechny psy - napø. atributy rasa, barva srsti a schopnosti štìkat. % tady prosim ten jazyk neopravujte, to je tak hezky :)!
 

Tøídy poskytují v objektovì-orientovaném programu modularitu a strukturu. Tøída by typicky mìla bıt rozpoznatelná i ne-programátorovi, kterı se ale v dané doménì problémù orientuje -- tzn. e charakteristiky tøídy by mìly \uv{dávat v kontextu smysl}. Podobnì i kód tøídy by mìl bıt relativnì samostané\uv{ ("self-contained")}. Vlastnosti a metódy tøíd se dohromady nazıvají i \emph{members}.
\end{obecne}

\begin{obecne}{Kontruktory}
\emph{Konstruktor} je v objektovì orientovaném programování speciální metoda tøídy, která se volá, kdy je instance pøislušného objektu této tøídy novì vytváøena.

Konstruktor se podobá ostatním metodám tøídy, ale liší se od nich tím, e nemá nikdy explicitní návratovı typ, nedìdí se a obvykle má jiná pravidla pro modifikátory pøístupu. Konstruktory inicializují datové èleny. Správnì napsanı konstruktor nechá objekt v „platném“ stavu.

Ve vìtšinì jazykù mùe bıt kontruktor pøetíen, take má jedna tøída nìkolik konstruktorù s odlišnımi parametry. Nìkteré jazyky (napø. C++) rozlišují speciální typy konstruktorù:
\begin{pitemize}
    \item implicitní konstruktor – konstruktor bez parametrù
    \item kopírovací konstruktor – konstruktor, kterı má jeden parametr typu dané tøídy (nebo reference na ní)
\end{pitemize}

\end{obecne}

\begin{obecne}{Dìdiènost}Objekty jsou organizovány stromovım zpùsobem, kdy objekty nìjakého druhu mohou dìdit z jiného druhu objektù, èím pøebírají jejich schopnosti, ke kterım pouze pøidávají svoje vlastní rozšíøení. Tato myšlenka se obvykle implementuje pomocí rozdìlení objektù do tøíd, pøièem kadı objekt je instancí nìjaké tøídy. Kadá tøída pak mùe dìdit od jiné tøídy (v nìkterıch programovacích jazycích i z nìkolika jinıch tøíd). Umoòuje zacházet s~mnoinou tøíd, jako by byly všechny reprezentovány tím samım objektem. Napøíklad známá hierarchie: grafickı objekt, bod, krunice. Navíc je to prostøedek pro úsporu práce pøi kódování.
\\\\
Máme dva druhy dìdiènosti podle násobnosti:
\begin{pitemize}
        \item Jednoduchá dìdiènost - kadá podtøída dìdí pouze z jedné supertøídy
        \item Vícenásobná dìdiènost - mùeme dìdit z více tøíd
\end{pitemize} 
A další dva druhy dìdiènosti podle pouití:
\begin{pitemize}
        \item Implementation Inheritance: in which class inherits one class and implement/override its methods and properties for example Control object in which System.Windows.Forms.Textbox,System.Windows.Forms.Button both inherits their self from control class. But provides different functionality
        \item Interface inheritance: in which a class inherits from Interface. For example IDisposable. It just inherits definition not implementation. Any type which does interface inheritance it means that it will provide defined functionality called as “Contract”.
\end{pitemize} 
\\\\
\textbf{Implementace dìdiènosti v C++:} Je-li tøída B (pøímım èi nepøímım) potomkem tøídy A, pak pamìová reprezentace objektu typu B obsahuje èást, která má stejnı tvar jako pamìová reprezentace samostatného objektu typu A. Z kadého ukazatele na typ B je mono odvodit ukazatel na èást typu A -- tato konverze je implicitní, tj. není tøeba ji explicitnì uvádìt ve zdrojovém kódu. Tato konverze mùe (obvykle pouze pøi násobné dìdiènosti) vyadovat jednoduchı vıpoèet (pøiètení posunutí).

Z ukazatele na typ A je mono odvodit ukazatel na typ B, jen pokud konkrétní objekt, do kterého ukazuje ukazatel na typ A, je typu B (nebo jeho potomka). Zodpovìdnost za ovìøení skuteèného typu objektu má programátor a tuto konverzi je tøeba explicitnì vynutit pøetypováním. Mùe to znamenat odeètení posunutí v pamìti.

\end{obecne}
\begin{obecne}{Dìdiènost typu Diamant}
Vícenásobná dìdiènost bohuel pøináší øadu problémù. Z toho dùvodu celá øada objektovì orientovanıch jazykù nepodporuje
vícenásobnou dìdiènost. Jeden z pøíkladù je \emph{dìdiènost typu diamant}, kde tøídy B a C jsou
potomci nìjaké tøídy A. Potom má tøída D, potomek tøídy B a C, atributy z prapøedka A
dvakrát. To lze øešit pomocí virtuální dìdiènosti.
  \begin{figure}[!ht]
    \begin{center}
      \includegraphics[scale=1.7]{informatika/programovanie/obrazky/diamond_inheritance.png}
      \caption{Diamond problem}
    \end{center}
  \end{figure}
\\\\  
\textbf{Implementace problému Diamant v C++:} Postupuje po obou cestách oddìlenì, take objekt D pak obsahuje
2 separátní A objekty a kód pravdìpodobnì skonèí na COMPILE ERROR. Pokud je dìdiènost z A do B a A do C oznaèena jako "virtual" (napøíklad
"class B : virtual public A"), C++ pak vytvoøí pouze 1  A objekt a jeho èásti
budou správnì fungovat. Pokud ale smícháme na obou
virtuální a nevirtuální dìdiènost dojde také ke COMPILE ERROR - pøi pøístupu
k èástem A z D. 

 
\end{obecne}
\begin{obecne}{Virtuální metody}
V objektovì orientovaném programování se pod pojmem virtuální funkce nebo virtuální metoda myslí funkce/metoda (v kódu oznaèená klíèovım slovem – typicky virtual), její chování je urèeno definicí v posledním objektu (ve smìru dìdiènosti od rodièù k potomkùm), kterı definici funkce s danou signaturou obsahuje. Tento koncept je dùleitou souèástí polymorfismu v objektovì orientovaném programování.
\\\\Koncept virtuálních funkcí øeší následující problém:

Kdy v OOP dìdí nìjaká tøída od jiné, tak instance podìdìné tøídy mùe bıt pøetypována na libovolného ze svıch pøedkù. Pokud však podìdìná tøída pøedefinovala podìdìnou metody, nebude pøi jejím pøetypování na pøedka jasné, kterou z definicí metody pouít.
\\\\
Rozhodnutí otázky, kterou funkci zavolat, pøináší právì rozdìlení metod na virtuální a nevirtuální. Kdy je funkce oznaèena jako virtuální, je pouita definice funkce z podìdìné tøídy (pokud existuje). V opaèném pøípadì je pouita definice ze tøídy na kterou je instance tøídy právì pøetypována.
\\\\
\emph{Pozdní vazba (late binding; virtual call):} Je-li metoda nìjaké tøídy virtuální èi èistì virtuální, pak všechny metody se stejnım jménem, poètem a typy parametrù deklarované v potomcích tøídy jsou povaovány za rùzné implementace tée funkce. Která implementace se vybere, tedy které tìlo bude zavoláno, se rozhoduje a za bìhu programu podle skuteèného typu celého objektu. Pouije se tìlo z posledního potomka, kterı definuje tuto funkci a je souèástí celého objektu. Pozdní vazba má smysl pouze u vyvolání na objektu urèeném odkazem.

Pozdní vazba je implementaènì umonìná skrytım pointerem na \emph{tabulku virtuálních funkcí (VMT)} uvnitø kadého objektu. Existuje pro kadou tøídu jedna. Pøi dìdiènosti zùstává v celém objektu odkaz jeden (v C++ jich mùe
bıt pøi vısenásobné dìdiènosti i více), ale (i pro \uv{nejvnitønìjší} bázovou tøídu) odkazuje na tabulku odvozené tøídy. V tabulce musí bıt proto pointery na funkce, deklarované u u bázové tøídy, umístìny na zaèátku (aby bylo moné volat funkce bázové tøídy mezi sebou bez zmìny kódu).
\end{obecne}



\begin{obecne}{Polymorfismus}Odkazovanı objekt se chová podle toho, jakı je jeho skuteènı typ. Pokud nìkolik objektù poskytuje stejné rozhraní, pracuje se s nimi stejnım zpùsobem, ale jejich konkrétní chování se liší. V praxi se tato vlastnost projevuje napø. tak, e na místo, kde je oèekávána instance nìjaké tøídy, mùeme dosadit i instanci libovolné její podtøídy (tøídy, která pøímo èi nepøímo z této tøídy dìdí), která se mùe chovat jinak, ne by se chovala instance rodièovské tøídy, ovšem v rámci \uv{mantinelù}, danıch popisem rozhraní.
\end{obecne}
\newpage
\begin{obecne}{Pøíklad polymorfismu, dìdiènosti (pøípadnì zapouzdøení) v C\#:}
\begin{footnotesize}
\begin{verbatim}
namespace Program
{
    public interface IAnimal
    {
        string Name { get; }
        string Talk();
    }
    
    public abstract class AnimalBase
    {
        public string Name { get; private set; }
 
        protected AnimalBase(string name) {
            Name = name;
        }
    }
 
    public class Cat : AnimalBase, IAnimal
    {
        public Cat(string name) : base(name) {
        }
 
        public string Talk() {
            return "Meowww!";
        }
    }
 
    public class Dog : AnimalBase, IAnimal
    {
        public Dog(string name) : base(name) {            
        }
 
        public string Talk() {
            return "Arf! Arf!";
        }
    }
    
    public class TestAnimals
    {
        // prints the following:
        //   Missy: Meowww!
        //   Mr. Mistoffelees: Meowww!
        //   Lassie: Arf! Arf!
        //
        public static void Main(string[] args)
        {
            var animals = new List<IAnimal>() {
                new Cat("Missy"),
                new Cat("Mr. Mistoffelees"),
                new Dog("Lassie")
            };
 
            foreach (var animal in animals) {
                Console.WriteLine(animal.Name + ": " + animal.Talk());
            }
        }
    }
}
\end{verbatim}
\end{footnotesize}
\end{obecne}

