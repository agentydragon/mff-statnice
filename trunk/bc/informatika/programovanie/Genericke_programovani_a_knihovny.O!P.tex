\newpage\subsection{Generické programování – šablony a generika}

Základní myšlenkou, která se skrıvá za pojmem generické programování, je \textbf{rozdìlení kódu programu na algoritmus a datové typy takovım zpùsobem, aby bylo moné zápis kódu algoritmu chápat jako obecnı, bez ohledu na to, nad jakımi datovımi typy pracuje}. Konkrétní kód algoritmu se z nìj stává dosazením datového typu.
\par
U kompilovanıch jazykù dochází k rozvinutí kódu v dobì pøekladu. Typickım pøíkladem jazyka, kterı podporuje tuto formu generického programování, je jazyk C++. Mechanismem, kterı zde generické programování umoòuje, 
jsou takzvané šablony (templates).

\medskip
\begin{poznamkaN}{Metaprogramování a Generické programování}
Generické programování se liší od normálního tím, e rozšiøuje jazyk o monosti metaprogramování. Úzce souvisí s metaprogramováním, ale negeneruje ádnı další zdrojovı kód (alespoò ne takovı jakı by vidìl programátor). Liší se od maker, protoe ty provádìjí jen preprocesorové "search-and-replace" a nejsou souèástí gramatiky jazyka (viz níe podrobnìjší srovnání). Jediná vyjímka jsou makra a v Common Lisp, kde parsují stromy a ne text (?? zkontrolovat Lisp).
\end{poznamkaN}

\begin{definiceN}{Šablony}
Šablony jsou pouívány kompilátorem pro vygenerování doèasného zdrojového kódu, kterı se pak spojí se zbytkem a je pak zkompilován. Vıstup šablon mùou tvoøit compile-time konstanty , datové struktury i celé funkce. Pouití šablon mùe bıt chápáno jako spouštìní kódu bìhem kompilace. Tato technika je pouívána v mnoha jazycích, napøíklad C++, Curl, D a XL.

Obyèejné fce v C++ mají pøednost pøed generickımi.
\end{definiceN}

\begin{prikladN}{Tøída parametrizovaná typem (kontejner)}
Pøíklad ukazuje vıhodu generického programování, místo abychom psali specifickou implementaci pro kadı typ (i kdy bude kód témìø identickı), vytvoøíme si šablonu tøídy:
\begin{verbatim}
  template<typename T> 
  class List 
  { 
    T x;
    List<T> *next;
  };
  
  List<Animal> list_of_animals;
  List<Car> list_of_cars;
  
  ...
  
  conductor = root;
  while ( conductor != NULL ) {
    cout<< conductor->x;
    conductor = conductor->next;
  }
\end{verbatim}
T reprezentuje typ kterı bude instanciován. Vygenerovanı List se pak chová jako List podle urèeného typu. Tyto "kontejnery-typu-T", bìnì nazıvané generiky (anglicky "generics"), je programovací technika umoòující definici tøídy která pøijímá a obsahuje rùzné datové typy (nepleme si teï s dynamickım polymorfismem, kterı je algoritmicky pouívá zámìnné podtøídy). I kdy toto je nejèastìjší pouití generického programování (a nìkteré jazyky implementují pouze tento aspekt), generické programování obsahuje i další techniky. 
\end{prikladN}

\begin{prikladN}{Šablony vs. makra}
V mnoha smìrech šablony fungují stejnì jako šablony pre-procesoru, nahrazují šablonovanou promìnnou danım typem. Na druhou stranu je tu mnoho rozdílù mezi makrem jako toto:
\begin{verbatim}
    #define min(i, j) (((i) < (j)) ? (i) : (j))
\end{verbatim}
a a šablonou:
\begin{verbatim}
    template<class T> T min (T i, T j) { return ((i < j) ? i : j) }
\end{verbatim}
Makro má napøíklad tyto problémy:
\begin{pitemize}
\item Kompilátor nemùe zkontrolovat jestli jsou parametry makra (tj. i,j) kompatibilní typy. Makro se pouije bez typové kontroly.
\item Hodnoty i a j jsou vyhodnoceny dvakrát. Napøíklad pokud jeden parametr pouívá post-inkrementaci je provedena dvakrát (?? tohle chce ovìøit).
\item Protoe jsou makra jsou interpretována preprocesorem, chybové zprávy kompilátoru budou ukazovat na "rozbalenı" vısledek makra v kódu a ne na makro (i kdy chyba bude v nìm).\end{pitemize}
\end{prikladN}

\begin{prikladN}{Faktoriál pomocí šablon}
Tento pøíklad jasnì ukazuje vıhodu nad makry, v nich takto jednoduše rekurzivní konstrukce napsat nejde (alespoò v C++ ne).
\begin{verbatim}
  template <int N>
  struct Factorial 
  {
      enum { value = N * Factorial<N - 1>::value };
  };
   
  template <>
  struct Factorial<0> 
  {
      enum { value = 1 };
  };
   
  // pouití:
  int x = Factorial<4>::value; // == 24
  int y = Factorial<0>::value; // == 1
\end{verbatim}
\end{prikladN}


\begin{prikladN}{traits}
Programovací technika vyuívající šablony, ze kterıch nejsou vytváøeny objekty. Urèeny k doplnìní informací o nìjakém typu.
\\\\Obsahují pouze definice typù a statické funkce.

\begin{verbatim}
  template< typename T > struct is_void{ 
    static const bool value = false;
  };
  
  template<> struct is_void< void >{ 
    static const bool value = true; 
  };
  
  // pouití:
  is_void<int>::value; // false
  is_void<void>::value; // true
\end{verbatim}
\end{prikladN}
\newpage
\begin{prikladN}{policy classes}
Urèeny k definování urèitého chování. Jsou to tøídy, ze kterıch obvykle nejsou vytváøeny objekty a jsou pøedávány jako parametr šablonám. Defaultní hodnotou parametru èasto bıvá šablona traits. Hlavnì spojené s C++ (v ostatních jazycích se zatím nerozšíøilo).
\begin{verbatim}
  template < typename output_policy, typename language_policy >
  class HelloWorld : public output_policy, public language_policy
  {
      using output_policy::Print;
      using language_policy::Message;
       
      public: void Run() //behaviour method
      {
          //two policy methods
          Print( Message() );
      }
  };
   
  class OutputPolicy_WriteToCout
  {
   protected:
      template< typename message_type >
      void Print( message_type message )
      {
          std::cout << message << std::endl;
      }
  };
   
  class LanguagePolicy_English
  {
      protected: std::string Message() { return "Hello, World!"; }
  };
   
  class LanguagePolicy_German
  {
      protected: std::string Message() { return "Hallo Welt!"; }
  };
   
  int main()
  {
      /* example 1 */
      HelloWorld<OutputPolicy_WriteToCout, LanguagePolicy_English>  hello_world;
      hello_world.Run(); // Prints "Hello, World!"
   
     /* example 2 
      * does the same but uses another policy, the language has changed
      */
      HelloWorld<OutputPolicy_WriteToCout, LanguagePolicy_German> hello_world2;
      hello_world2.Run(); // Prints "Hallo Welt!"
  }
\end{verbatim}
\end{prikladN}
\newpage
\begin{definiceN}{Dynamickı (run-time) polymorfismus}
Dìdìní + VMT = flexibilita. Zde uvedeno jako jako srovnání k šablonám.
\begin{verbatim}
class Base
{
public:
    virtual void method() { std::cout << "Base"; }
    virtual ~Base() {}
};
 
class Derived : public Base
{
public:
    virtual void method() { std::cout << "Derived"; }
};
 
int main()
{
    Base *pBase = new Derived;
    pBase->method(); //outputs "Derived"
    delete pBase;
    return 0;
}
\end{verbatim}

Lze rozšíøit o šablony.
\end{definiceN}

\begin{definiceN}{Statickı (compile-time) polymorfismus}
Je pøetìování fukcí a operátorù, øeší se pøi kompilaci = rychlost.
Pøípadnì jeho varianta s šablonami:
\begin{verbatim}
template <class Derived>
struct base
{
    void interface()
    {
         // ...
         static_cast<Derived*>(this)->implementation();
         // ...
    }
};
 
struct derived : base<derived>
{
     void implementation();
};
\end{verbatim}
Lze tak dosáhnout podobnıch vìcí jako s VMT.
\end{definiceN}

\begin{obecne}{Pouití v programovacích jazycích}
Jazyk D také nabízí plnì generické šablony zaloené na svém pøedchùdci C++ ale má jednodušší syntaxi. Java má syntaxi generického programování zaloenou na  C++ od uvedení J2SE 5.0 a implementuje generiky (anglicky "generics") neboli "kontejnery-typu-T" (tedy pouze podmnoinu generického programování).
\end{obecne}

\begin{reportN}{IP 21.6.2011} Co je to generické programování, k èemu se pouívá a v èem spoèívají jeho vıhody?

Napište struènou implementaci generické tøídy List nebo HashTable.

Popište implementaci v C++ a Javì (asi by staèil i C\#, ale v zadání byla explicitnì napsaná java).
\end{reportN}

\begin{reportN}{IP 21.6.2011 ($<$2007)} Popiste sablony
\\Jak jsou implementovany (popiste jak jsou implementovany v C++ nebo Java) (to som teda fakt netusil)
\end{reportN}

\begin{reportN}{IOI 21.6.2011 ($<$2007)}
Co je to generické programování, k èemu se pouívá a v èem spoèívají jeho vıhody?

Napište struènou implementaci generické tøídy List nebo HashTable.
\end{reportN}

\begin{reportN}{Yaghob}
Co je to traits a policy classes, co je to statickı polymorfismus apod. Nakonec jsem to nìjak vymyslel a shodli jsme se na tom, e to vím, take taky za 1.
\end{reportN}
