\subsection{Procesory, multiprocesory}

\begin{e} {Definice}{0}{Procesor}
Procesor (CPU – central processing unit) je ústøední vıkonnou jednotkou poèítaèe, která ète z pamìti instrukce a na jejich základì vykonává program.

Základnımi súèasami procesora sú:
\begin{pitemize}
	\item øadiè nebo øídicí jednotka, která øídí tok programu, tj. naèítání instrukcí, jejich dekódování, naèítání operandù instrukcí z operaèní pamìti a ukládání vısledkù zpracování instrukcí
	\item sada registrù k uchování operandù a mezivısledkù.
	\item jedna nebo více aritmeticko-logickıch jednotek (ALU), které provádí s daty aritmetické a logické operace.
	\item nìkteré procesory obsahují jednu nebo nìkolik jednotek plovoucí èárky (FPU), které provádí operace v plovoucí øádové èárce.
\end{pitemize}
\end{e}

\begin{e}{Poznámka}{0}{0}
Súèasné procesory navyše èasto obsahujú ïalšie rozsiahle funkèné bloky (cache, rôzne periférie)~-- ktoré z \uv{ortodoxného hladiska} nie sú priamo súèasou \emph{jadra procesoru}. Niektoré procesory môu obsahova viac jadier (+logiku slúiacu k ich vzájomnému prepojeniu). Ïalším trendom je SoC (System on Chip), kde sa na èipe procesora nachádzajú aj ïalšie subsystémy napr. na spracovanie zvuku, grafiky alebo pripojenie externıch periférií (takéto riešenia sa vyuívajú väèšinou v PDA, domácej elektronike, mobiloch atï.).
\end{e}

\begin{obecne}{Dìlení podle instruèní sady}
Pod¾a inštrukènej sady je moné procesory rozdeli na:
\begin{pitemize}
	\item \textbf{CISC} (Complex Instruction Set Computer): poskytuje rozsiahlu inštrukènú sadu spolu s rôznymi variantami inštrukcií. Jedna inštrukcia napr. môe vykona ve¾a low-level operácií (naèítanie z pamäti, vykona aritmetickú operáciu a vısledok uloi). Takéto inštrukcie zjednodušovali zápis programov (inštrukcie boli blišie vyšším programovacím jazykom) a zmenšovali ve¾kos programu a poèet prístupov do pamäti~-- èo bolo v 60tych rokoch dôleité. Avšak nie vdy je vykonanie jednej zloitej operácie rıchlejšie ako vykonanie viac menej zloitıch miesto toho (napr. kvôli zloitému dekódovaniu a pouitiu mikrokódu na volanie jednoduchıch \uv{podinštrukcií}). Príkladmi CISC architektúr procesorov sú System/360, Motorola 68000 a Intel x86. V súèasnosti napr. x86 rozkladá zloité inštrukcie na \uv{micro-operations} ktoré môu by pipeline-ou spracované paralelne a vyšší vıkon je tak dosahovanı na väèšom rozsahu inštrukcií. Vïaka tomu sú súèasné x86 procesory minimálne rovnako vıkonné ako ozajstné RISC architektúry.
	\item \textbf{RISC} (Reduced Instruction Set Computer): design CPU ktorı uprednosòuje jednoduchšiu inštrukènú sadu a menšiu zloitos adresovacích modelov~-- vïaka èomu je moné dosiahnu lacnejšiu implementáciu, väèšiu úroveò paralelizmu a úèinnejšie kompilátory. Dôvodom vzniku bolo aj nevyuívanie celej CISC inštrukènej sady a upredòostòovania len obmedzenej podmnoiny (designéri procesorov potom optimalizovali len tieto podmnoiny a tak sa zvyšné inštrukcie pouívali ešte menej...). Kvôli väèšiemu poètu inštrukcií však musia RISC procesory èastejšie pristupova k pamäti... Príkladmi RISC procesorov sú napr. SPARC a ARM. V architekturách typu \textbf{Post-RISC} jde o spojení RISCovıch vlastností s technikami zvıšení vıkonu, jako je out-of-order vykonávání a paralelismus.
    \item \textbf{VLIW}: Very Long Instruction Word or VLIW refers to a CPU architecture designed to take advantage of instruction level parallelism (ILP). A processor that executes every instruction one after the other (i.e. a non-pipelined scalar architecture) may use processor resources inefficiently, potentially leading to poor performance. The performance can be improved by executing different sub-steps of sequential instructions simultaneously (this is pipelining), or even executing multiple instructions entirely simultaneously as in superscalar architectures. The VLIW approach, on the other hand, executes operation in parallel based on a fixed schedule determined when programs are compiled. Since determining the order of execution of operations (including which operations can execute simultaneously) is handled by the compiler, the processor does not need the scheduling hardware that the three techniques described above require. As a result, VLIW CPUs offer significant computational power with less hardware complexity (but greater compiler complexity) than is associated with most superscalar CPUs.
    \item \textbf{EPIC}: (Nìkdy oznaèován za poddruh VLIW) Explicitly Parallel Instruction Computing (EPIC) is a computing paradigm that began to be researched in the 1990s. This paradigm is also called Independence architectures. It was used by Intel and HP in the development of Intel’s IA-64 architecture, and has been implemented in Intel’s Itanium and Itanium 2 line of server processors. The goal of EPIC was to increase the ability of microprocessors to execute software instructions in parallel, by using the compiler, rather than complex on-die circuitry, to identify and leverage opportunities for parallel execution. This would allow performance to be scaled more rapidly in future processor designs, without resorting to ever-higher clock frequencies, which have since become problematic due to associated power and cooling issues.
\end{pitemize}
\medskip
TODO: asi opravit, moná zpøesnit VLIW a EPIC a urèitì pøeloit

\medskip
Øekneme, e procesor má \emph{ortogonální instrukèní sadu}, pokud ádná instrukce nepøedpokládá implicitnì pouití nìkterıch registrù. To umoòuje jednodušší práci algoritmùm pøidìlování registrù v pøekladaèích. Pøíkladem neortogonální instrukèní sady je i x86.
\end{obecne}

\begin{obecne}{Další dìlení}
Ïalej je moné procesory rozdeli pod¾a dåky operandov v bitoch (8, 16, 32, 64...), ktorı je procesor schopnı spracova v jednom kroku. V embedded zariadeniach sa najèastejšie pouívajú 4- a 8-bitové procesory. V PDA, mobiloch a videohrách 8 resp. 16 bitové. 32 a viac bitov vyuíajú napr. osobné poèítaèe a laserové tlaèiarne.

Dôleitou vlastnosou je aj taktovacia frekvencia jadra, MIPS (millions of instructions per second) a jeho rıchlos. V súèasnosti je aké dáva do súvislosti vıkon procesorov s ich frekvenciou (resp. MIPS)~-- kım Pentium zvládne na vıpoèet vo floatoch, jednoduchı 8-bitovı PIC na to potrebuje ove¾a viac taktov. Ïalším \uv{problémom} je superskalarita procesorov, ktorá im umoòuje vykona viacero nezávislıch inštrukcií poèas jedného taktu.
\end{obecne}

\begin{obecne}{Techniky pro zvıšení vıkonu}
Zvyšova vıkon (procesorov) je moné viacerımi spôsobmi. Najjednoduchším (a najpomalším) typom je Subskalárny CPU (naèíta a spracúva len jednu inštrukciu naraz~-- preto musí celı procesor èaka kım vykonávanie inštrukcie skonèí; je tak zdrovanı dlhšie trvajúcimi inštrukciami). 

\begin{center}
\includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/Nopipeline.png}
\end{center}

Pokusy o dosiahnutie skalárneho a lepšieho vıkonu vyústili do designov ktoré sa správajú menej lineárne a viac paralelne. Èo sa tıka paralelizmu v procesoroch, pouívajú sa dva druhy pojmov na ich klasifikáciu~-- \emph{Instruction level parallelism} (zvyšovanie rıchlosti vykonávania inštrukcií v procesore a teda zväèšovanie vyuitia prostriedkov na èipe) a \emph{Thread level parallelism} (zväèšovanie poètu vlákien, ktoré dokáe CPU vykonáva naraz).
\begin{pitemize}
  \item \textbf{pipeline}: 
  Zlepšenie je moné dosiahnú pomocou \uv{instruction pipelining}-u, ktoré je pouíté vo väèšine modernıch procesorov. Umoòuje vykonanie viac ako jednej inštrukcie v jednom kroku vïaka rozloeniu spracovávania inštrukcie na viac menších krokov: 
  \begin{center}
  \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/Fivestagespipeline.png}
  \end{center}

  \item \textbf{superskalarita}: Dialša monos je pouitie superscalar designu, ktorı obsahuje dlhú inštrukènú pipeline a viacero identickıch execution jednotiek.  
  \begin{center}
  \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/Superscalarpipeline.png}
  \end{center}	

  \item \textbf{Out of order execution}
  \begin{penumerate}
	  \item Naètení instrukce, pøípadnì její rozdrobení na mikroinstrukce
	  \item Zaøazení do vyèkávací stanice (instruction pool)
	  \item Instrukce èeká na všechny svoje operandy
	  \item Instrukce se vykoná ve své vıkonné jednotce (je vybírána z instruction poolu nezávisle na ostatních)
	  \item Vısledky se uchovají ve frontì (reorder buffer)
	  \item A se všechny starší instrukce zapíší do registrù, zapíše se vısledek této instrukce (opìtovné øazení)
  \end{penumerate}

  \item \textbf{Predikce skokù}~-- hluboké pipeliny mají problém, pokud podmínìnı skok není proveden; dynamická predicke skokù (historie CPU~-- vzory nìjaké hloubky) vs. statická (bez nápovìdy~-- skok vpøed se neprovede, skok vzad se provede; s nápovìdou~-- pøekladaè odhaduje pravdìpodobnost skoku)

  \item \textbf{Spekulativní vykonávaní}~-- vykonávání kódu, kterı nemusí bıt zapotøebí; vıznamná disproporce mezi rychlostí CPU a pamìti; typické vyuití je znaèné pøedsunutí ètecích operací; CPU provádí i odsouvání zápisovıch operací


  \item \textbf{Data parallelism}: SIMD inštrukcie (napr. multimediálne inštrukcie), vektorové procesory...
\end{pitemize}
\end{obecne}

\subsubsection*{Multiprocesory}

TODO: jde o copy \& paste z Wiki ... pøedìlat èesky/slovensky
\medskip

\begin{e}{Definice}{0}{Multiprocesor}
  O \emph{multiprocesoru} mluvíme, pokud je pouito dvou nebo více procesorù
  (CPU) v rámci jednoho poèítaèového systému. Termín je také pouíván mluvíme-li
  o schopnosti systému vyuívat více procesorù a/nebo schopnosti rozdìlovat
  úlohy mezi jednotlivımi procesory.
\end{e}

\begin{obecne}{Vztah k datùm a instrukcím}
In multiprocessing, the processors can be used to execute a single sequence of instructions in multiple contexts (single-instruction, multiple-data or SIMD, often used in vector processing), multiple sequences of instructions in a single context (multiple-instruction, single-data or MISD, used for redundancy in fail-safe systems and sometimes applied to describe pipelined processors or hyperthreading), or multiple sequences of instructions in multiple contexts (multiple-instruction, multiple-data or MIMD).
\end{obecne}

\begin{obecne}{Symetrie}
In a multiprocessing system, all CPUs may be equal, or some may be reserved for special purposes. A combination of hardware and operating-system software design considerations determine the symmetry (or lack thereof) in a given system. For example, hardware or software considerations may require that only one CPU respond to all hardware interrupts, whereas all other work in the system may be distributed equally among CPUs; or execution of kernel-mode code may be restricted to only one processor (either a specific processor, or only one processor at a time), whereas user-mode code may be executed in any combination of processors. Multiprocessing systems are often easier to design if such restrictions are imposed, but they tend to be less efficient than systems in which all CPUs are utilized equally.

Systems that treat all CPUs equally are called symmetric multiprocessing (SMP) systems. In systems where all CPUs are not equal, system resources may be divided in a number of ways, including asymmetric multiprocessing (ASMP), non-uniform memory access (NUMA) multiprocessing, and clustered multiprocessing (qq.v.).
\end{obecne}

\begin{obecne}{Tìsnost spojení multiprocesorù}
\begin{pitemize}
    \item \textbf{Tightly-coupled} multiprocessor systems contain multiple CPUs that are connected at the bus level. These CPUs may have access to a central shared memory (SMP or UMA), or may participate in a memory hierarchy with both local and shared memory (NUMA). The IBM p690 Regatta is an example of a high end SMP system. Intel Xeon processors dominated the multiprocessor market for business PCs and were the only x86 option till the release of AMD's Opteron range of processors in 2004. Both ranges of processors had their own onboard cache but provided access to shared memory; the Xeon processors via a common pipe and the Opteron processors via independent pathways to the system RAM.

    \item \textbf{Chip multiprocessors}, also known as multi-core computing, involves more than one processor placed on a single chip and can be thought of the most extreme form of tightly-coupled multiprocessing. Mainframe systems with multiple processors are often tightly-coupled.

    \item \textbf{Loosely-coupled multiprocessor} systems (often referred to as clusters) are based on multiple standalone single or dual processor commodity computers interconnected via a high speed communication system (Gigabit Ethernet is common). A Linux Beowulf cluster is an example of a loosely-coupled system.
\end{pitemize}
Tightly-coupled systems perform better and are physically smaller than loosely-coupled systems, but have historically required greater initial investments and may depreciate rapidly; nodes in a loosely-coupled system are usually inexpensive commodity computers and can be recycled as independent machines upon retirement from the cluster.

\textbf{SMP} (Symmetric Multiprocessing): viac procesorov so zdie¾anou operaènou pamäou (nutné mechanizmy na zabránenie nesprávnych náh¾adov na pamä a migráciu procesov medzi procesormi). SMP systems allow any processor to work on any task no matter where the data for that task are located in memory; with proper operating system support, SMP systems can easily move tasks between processors to balance the workload efficiently.
\end{obecne}
