\subsection{Synchronizaèní primitiva, vzájemné vylouèení}

Obecne se jedna o synchronizaci "runnable" entit - vlaken nebo procesu
podle toho, co je pro dany OS "runnable" entita.
\begin{description}
  \item[Lock-Free] - akce na sdílené dat.struktuøe nevyadující zámky (napøíklad pøidání
  do fronty)
  \item[Deadlock] - situace kdy dva nebo více procesù èeká na dokonèení akce
vzájemnì, take se navzájem na sebe èekají donekoneèna (viz problém filosofù
níe)
  \item[Èasové závislé chyby (Race Conditions)] Situace kde 2 nebo více procesù pøistupuje ke stejnému sdílenému prostøedku, a finální vısledek záleí na kdo probìhne kdy. Pøíklad na tiskové frontì:
  \begin{center}
    \includegraphics[width=13cm]{informatika/operacne_systemy_a_hw/obrazky/race-conditions.png}
  \end{center}
        \item[Kritická sekce (Critical Regions)] èást programu, která dokud není dokonèena není moné zaèít jinou (napø. pouívá sdílené prostøedky)
  \begin{center}
    \includegraphics[width=9cm]{informatika/operacne_systemy_a_hw/obrazky/critical-region.png}
  \end{center}  
        \item[Vzájemné vylouèení (Mutual Exclusion)] mechanismus,
ktery zarucuje, aby v jedne kriticke sekci bylo nejvyse jedno vlákno/proces v
jeden cas. Podmínky pro správné fungování vzájemného vylouèení:
\begin{penumerate}
        \item ádné dva procesy nemohou bıt najednou ve stejné kritické sekci
        \item Nemohou bıt uèinìny ádné pøedpoklady o rychlosti procesu (ádné odhady rychlosti nebo priorit procesu, musí fungovat se všemi procesy)
        \item ádnı proces mimo kritickou sekci nesmí blokovat jinı proces
        \item ádnı proces nesmí èekat nekoneènì dlouho v kritické sekci (jinak dead-lock)
\end{penumerate}
Metody dosáhnutí vzájemného vylouèení: aktivní èekání (busy waiting) a pasivní èekání/blokování.
\end{description}

\subsubsection*{Aktivní èekání (Busy Waiting, Polling)}
\emph{Vlastnosti}: \textbf{spotøebovává èas procesoru}, vhodnìjší pro pøedpokládané krátké doby èekání, nespotøebovává prostøedky OS, rychlejší.

Navrhovaná øešení: 
\begin{pitemize}
  \item \textbf{Zakázání pøerušení} - nevhodné - proces má plnou kontrolu nad poèítaèem (instrukce CLI - clear interrupt flag a STI - set interrupt flag) normální proces to nemùe udìlat, maximálnì v kernelu (na viceprocesorovem
stroji nebude fungovat)
  \item \textbf{Zámky v promìnné} - nefungují - mezi pøeètìníma nastavením locku mùe bıt program pøerušen - pak by si "nevšim" lock == 1 a vesel pokraèoval, akorát jsme pøidali novou race condition. 
\begin{verbatim}
int lock;
void proc(void) {
  for (;;) {
    nekritická_sekce();
    while (lock != 0);
    lock = 1;
    kritická_sekce();
    lock = 0;
  }
}
\end{verbatim}
  \item \textbf{Dùsledné støídání (Strict Alternation)} funguje ale porušuje podmínku 3 - promìnná turn hlídá kdo je na øadì

\begin{verbatim}
int turn = 0;

void p0(void)                void p1(void)
{                            {
  for (;;) {                   for (;;) {
    while (turn != 0);           while (turn != 1);
    kritická_sekce();            kritická_sekce();
    turn = 1;                    turn = 0;
    nekritická_sekce();          nekritická_sekce();
  }                            }
}                            }
\end{verbatim}

  \begin{center}
    \includegraphics[width=9cm]{informatika/operacne_systemy_a_hw/obrazky/strict-alternation.png}
  \end{center}

\emph{Petersonovo øešení} - zobecnìní Strict Alternation pro N procesù, vıhodou je jeho nezávislost na HW, nevıhodou to e musíme dopøedu znát max poèet procesù a podle toho upravit algoritmus. V praxi
se nepouívá:
\begin{verbatim}
#define N 2                   /* poèet procesù, pro víc by se musel upravit */
 
int turn;
int interested[N];            /* kdo má zájem */
 
void enter_region(int process) {   /* process: kdo vstupuje */
    int other = 1-process;         /* èíslo opaèného procesu */
    interested[process] = TRUE;    /* mám zájem o vstup */
    turn = process;                  /* nastav pøíznak poøadí na sebe */
    while(turn == process && interested[other] == TRUE); /* aktivnì èeká na druhého jestli není */
}                                                        /* interested nebo mu neskoèil do cesty */

 
void leave_region(int process) {   /* process: kdo vystupuje */
    interested[process] = FALSE;   /* u odcházím */
}
\end{verbatim}
\footnotesize Now consider the case that both processes call enter\_region almost simultaneously.
Both will store their process number in turn. Whichever store is done last
is the one that counts; the first one is overwritten and lost. Suppose that process 1 stores last, so turn is 1. When both processes come to the while statement, process 0 executes it zero times and enters its critical region. Process 1 loops and does not enter its critical region until process 0 exits its critical region.\normalsize
 
  \item \textbf{Instrukce Test-and-Set Lock (TSL)} - atomická operace naètení-a-zmìny hodnoty na úrovni strojového kódu, nemùe bıt pøerušena je nutné aby ji podporoval HW (všechny souèasné procesory nìjakou mají):
\\
- implementace spin-locku (druh zámku, na nìj je tøeba aktivnì èekat – èekající proces, pøi èekání na spinlock spotøebovává CPU èas) - poøád ale ménì prostøedkù ne pøedchozí øešení  
\begin{verbatim}
enter_region:
    TSL   R,lock           ; naèti zámek do registru R a    
                           ; nastav zámek na 1                        
    CMP   R,#0             ; byl zámek nulovı?
    JNZ   enter_region     ; byl-li nenulovı, znova
    ret                    ; návrat k volajícímu - vstup do
                           ; kritické sekce
 leave_region:
    mov   lock,#0          ; ulo do zámku 0
    ret                    ; návrat k volajícímu
\end{verbatim}
\end{pitemize}

\subsubsection*{Pasivní èekání (Blokování)}
\emph{Vlastnosti}: proces je ve stavu blokován, vhodné pro delší doby èekání, \textbf{spotøebovává prostøedky OS}, pomalejší.

Postup pouívající Sleep/Wakeup (implementovány OS, atomické operace - sleep uspí volající proces, wakeup probudí udanı proces) nefunguje (viz Problém producent/konzument).
\begin{pitemize}
\item \textbf{Semafory} -- poèítá poèet probuzenıch, reprezentace volnıch a pøidìlenıch prostøedkù

Atomické operace (nesmí bıt pøerušeny):

\begin{description}
\item[down(semaphore* s)] -- pokud je volnı (\verb=s>0=) tak zabere semafor (\verb=s--;=) , jinak se uspí a a ve frontì èeká na uvolnìní
(nìkdy se také nazıvá \textbf{wait} nebo pùvodnì \textbf{P})
\item[up(semaphore* s)] -- uvolní semafor (\verb=s++;=), vzbudí èekající proces (pokud existuje) (nìkdy se také nazıvá  \textbf{signal} nebo pùvodnì  \textbf{V})
\end{description}
-nutná podpora OS (vìtšinou v kernelu)
 

\item \textbf{Mutex} - speciální (binární) typ semaforu, kde jsou povolené jen hodnoty 0 a 1 (\textbf{v up sa misto $s++;$ volá \verb=s=1;} ) se nazıva \emph{mutex}. Bez podpory OS se dá cca-implementovat pomocí TSL\footnote{Tanenbaum: Modern operating systems 3e, 2008, str.131} (TSL nám ho ale mìní na aktivní èekání!):
\begin{verbatim}
mutex_lock: TSL R, mutex       ; get and set mutex
            CMP R, #0          ; was it unlocked?
            JZ ok              ; if yes: jump to ok
            CALL thread_yield  ; if no: sleep
            JMP mutex_lock     ; try again acquiring mutex
            ok: RET
            
mutex_unlock: MOV mutex, #0    ; unlock mutex
              RET
\end{verbatim}
\item \textbf{Monitory} - implementovány pøekladaèem - konstrukt programovacího jazyka\footnote{napø. synchronized metody v Javì}, lze si pøedstavit jako tøídu C++ (všechny promìnné privátní, funkce mohou bıt i veøejné). Mutual Exclusion (vzájemné vylouèení) v jedné instanci (zajištìno synchronizací na vstupu a vıstupu do/z veøejnıch funkcí, synchronizace implementována synchronizacnim primitivem OS - semafor/mutex).

• Operace wait – atomicky odemknout zámek a usnout (uprostøed monitoru).

• Operace signal – probudí vlákno èekající na monitor (uspané operací wait). Toto
vlákno pøed vykonáváním kódu monitoru musí zámek monitoru opìt zamknout.
\begin{figure}[h]
  \centering
   \includegraphics[width=12cm]{informatika/operacne_systemy_a_hw/obrazky/producer-consumer-monitor.png}
   \caption{Problém producent konzument pomocí monitorù}
  \label{fig:pcm}
\end{figure}

\item \textbf{Zprávy}
\par Operace SEND a RECEIVE, zablokování odesílatele/pøíjemce, adresace proces/mailbox, rendez-vous... vhodné pro distribuované OS, pouívají se napøíklad ve WinAPI

\item \textbf{RWL - read-write lock}, \textbf{bariéry}...
\\\\
\textbf{Ekvivalence primitiv} - pomocí jednoho blokovacího primitiva lze implementovat jiné blokovací primitivum.
\\

\textbf{Rozdíly mezi platformami}: Windows - jednotné funkce pro pasivní èekání, èekání na více primitiv, timeouty. Unix - OS implementuje semafor, knihovna pthread.
\end{pitemize}
\subsubsection*{Klasické synchronizaèní problémy}
\begin{pitemize}
\item \textbf{Problém producent/konzument} - producent vyrába predmety, konzument ich spotrebúva. Medzi nimi je buffer pevnej ve¾kosti (N). Konzument nemá èo spotrebúva ak je buffer prázdny; producent prestane vyrába, ak je buffer plnı. 
\newpage
\begin{verbatim}
int N = 100;
int count = 0;
void producer(void) {
    int item;
    while(TRUE) {
        produce_item(&item);
        if(count==N) sleep ();
        insert_item(item);
        count++;
        if(count == 1) wake(consumer);
    }
}
void consumer(void) {
    int item;
    while(TRUE) {
        if(count==0) /*pozice A*/ sleep ();
        remove_item(&item);
        count--;
        if(count==N-1)
            wake(producer);
        consume_item(&item);
    }
}
\end{verbatim}
\begin{penumerate}
        \item Buffer je prázdny, a konzument práve preèítal count, aby zistil, èi je rovnı nule
        \item Preplánovanie na producenta ("pozice A")
        \item Producent vytvoøí item a zvıší count
        \item Producent zistí, èi je count rovnı jednej. Zistí e áno, èo znamená e konzument bol predtım zablokovanı (pretoe muselo by 0), a zavolá wakeup
        \item Teraz môe dôjs k zablokovaniu: konzument pokraèuje na "pozici
A" a uspí se, pretoe si myslí, e nemá èo zobra; producent bude chví¾u produkova a dôjde "preplneniu" $\Rightarrow$ uspí sa; spí producent aj konzument :o) 
\\
\par \textbf{Øešení pomocí semaforu\footnote{napsáno v C (Tanenbaum: Modern operating systems 3e, 2008, str.130), up() a down() si udrují seznamy spících vláken/procesù podle referencí na integery co jim dáme}:}
\begin{verbatim}
typedef int semaphore;
semaphore empty = 10;      //counting empty slots
semaphore full = 0;        //counting full slots
semaphore mutex = 1;       //mutex pro pøístup k bufferu

void producer() {
  while (TRUE) {
    int item = produce_item();
    down(&empty);          //possibly sleep, decrement empty counter
    down(&mutex);          //possibly sleep, claim mutex (set it to 0) thereafter
    insert_item(item);
    up(&mutex);            //release mutex, wake up other process
    up(&full);             //increment full counter, possibly wake up other ...
  }
}

void consumer() {
  while(TRUE) {
    down(&full);           //possibly sleep, decrement full counter
    down(&mutex);          //possibly sleep, claim mutex (set it to 0) thereafter
    item = remove_item();
    up(&mutex);            //release mutex, wake up other process
    up(&empty);            //increment empty counter, possibly wake up other ...
    consume_item(item);
  }
}
\end{verbatim}
\begin{figure}[h]
  \centering
   \includegraphics[width=17cm]{informatika/operacne_systemy_a_hw/obrazky/producer-consumer-semaphore.png}
  \caption{Øešení producent konzument pomocí semaforù}
  \label{fig:pcs}
\end{figure}
\end{penumerate}
\newpage
\item \textbf{Problém obìdvajících filosofù}
\par Pìt filosofù sedí okolo kulatého stolu. Kadı filosof má pøed sebou talíø špaget a jednu vidlièku. Špagety jsou bohuel slizké a je tøeba je jíst dvìma vidlièkami. ivot filosofa sestává z období jídla a období pøemıšlení. Kdy dostane hlad, pokusí se vzít dvì vidlièky, kdy se mu to podaøí, nají se a vidlièky odloí.

\item \textbf{Problém ospalého holièe}
\par Holiè má ve své oficínì køeslo na holení zákazníka a pevnı poèet sedaèek pro èekající zákazníky. Pokud v oficínì nikdo není, holiè se posadí a spí. Pokud pøijde první zákazník a holiè spí, probudí se a posadí si zákazníka do køesla. Pokud pøijde zákazník a holiè u støihá a je volné místo v èekárnì, posadí se, jinak odejde.
\end{pitemize}
\begin{reportN}{Bulej}
\begin{penumerate}
        \item priklad Producent-konzument pomoci semaforu

        \item stacilo napsat aktivni vs. pasivni, kriticka sekce, spinlock, semafor (obecne monitor) a pak nasledovalo par otazek, zda je mozne naprogramovat synch. primitivum bez podpory HW - podle me lze, od toho je Petersonovo øešení
\end{penumerate}
\end{reportN}

\begin{reportN}{Bulej}
Myslím, e jsem je pochopil, a kdy mi to pan Skopal vysvìtlil. To, co je v materiálech opravdu nestaèí. TSL je dobrı v tom, e má pravì operaci Test and Set Lock jako atomickou. Pak jsem se pokoušel udìlat semafor pro problém producent a konzument a dìlal jsem ho uplnì špatnì
\end{reportN}
\begin{reportN}{Bednárek}
Na tuhle jsem byl pøipravenı ze zadanıch otázek asi nejhùø, kupodivu jsem toho k ní ale nakonec na papír vyplodil pomìrnì dost a dostal k tématu jen málo doplòujících otázek (nìjaké drobné praktické a jak \textbf{implementovat mutex bez podpory OS, tj. pomocí test-and-set instrukce}), pak se plynule a nepozorovanì pøešlo na zablokování a zotavení z nìj. Nìco jsem vìdìl, vzpomnìl jsem si na 3 ze 4 Coffmanovıch podmínkek a jejich ošetøení, ètvrtou jsem pak vymyslel s Bednárkovou vydatnou pomocí. ádné otázky na "klasické synchronizaèní problémy" nebo Petersonovo øešení, tj. vìci, o kterıch jsem se sám radši nezmínil.

na konci sa opytal, ze aky problem okrem vyhladovania moze nastat... deadlock

Sleep/wakeup, semafory, monitory, správy, polling - u kadého ako funguje a èi to robí aplikácia/OS/HW. Potom sme sa pobavili o monosti implementova jedno druhım. 
\end{reportN}
\begin{reportN}{IP 9. 9. 2011}
Definujte rozhrani semaforu a jeho semantiku. Implementujte problém producent a konzument.
\\Postøeh k producentovi/konzumentovi byl, e vìtšina lidí zapomnìla zamykat pøístup k frontì mutexem.
\end{reportN}
\begin{reportN}{Hnìtınka}
na jednièku musíte umìt praktické uití (napø. z více mutexù postavit semafor)
\end{reportN}
\begin{e}{Øešení:}{0}{Implementation of General Semaphores Using Binary Semaphores
(Solution \#3),
Anthony Howe,
June 18, 2001}
pomocí 3 mutexù a counteru,  mutex barrier zabrani, aby do procedury Wait lezlo vic vlaken najednou:
\begin{verbatim}
var
    mutex=1: binary-semaphore;
    delay=0: binary-semaphore;
    barrier=1: binary-semaphore;
    C={initvalue}: integer;

Procedure Wait()
    begin
    wait(barrier);
    wait(mutex);
    C:=C-1;
    if C < 0 then begin
        signal(mutex);
        wait(delay);
        end
    else
        signal(mutex);
        signal(barrier);
    end

Procedure Signal()
    begin
    wait(mutex);
    C:=C+1;
    if C = 1 then
        signal(delay)
    signal(mutex)
    end
\end{verbatim}
\end{e}

\begin{e}{Report}{0}{IP 8.9.2011}
Definujte rozhrani semaforu a jeho semantiku.
\\\\Dale predpokladejme, ze cteni a prirazeni do promene ptr jsou atomicke, potom stale tento kod obsahuje race condition.
\\Urcete kde k ni dochazi, a opravte ji pomoci semaforu (ci jinak). Fce Consumer a Producer jsou spusteny prave jednou kazda z jineho vlakna.
\begin{verbatim}
    int* ptr = null;

    void Producent() {
        int data = SomeCoplexOperation();
        ptr = &data;
    }

    void Consumer() {
        while(ptr == null) { }
        printf("%i\n",&ptr);
    }
\end{verbatim}
\end{e}
\begin{e}{Øešení:}{0}{nejjednodušší øešení: \url{http://forum.matfyz.info/viewtopic.php?f=418&t=7873&p=33010#p33001}}
je tam ta race condition kvoli tomu, ze do ptr davame adresu lokalnej premennej ata moze byt uz odalokovana v dobe ked chce ku ptr pristupovat consumer
\begin{verbatim}
    int* ptr = null;
    int semaphore = 0;

    void Producent(){
        int data = SomeCoplexOperation();
        ptr = &data;
        down(semaphore);
    }

    void Consumer() {
        while(ptr == null) { }
        printf("%i\n",&ptr);
        up(semaphore);
    }
\end{verbatim}
odalokovanie sa deje az ked skonci telo procedury a to nemoze skoncit kym si consumer neprecita hodnotu pointera, nakolko na zaciatku je semafor nastaveny na nulu a tak down(semaphore) v tele producent uspi tuto proceduru/vlakno az kym sa nezavola up(semaphore) v tele consumer po precitani ptr
\end{e}

\begin{e}{Øešení:}{0}{praktické øešení}
umoòuje vıcenásobné spouštìní
\begin{verbatim}
    typedef int semaphore;
    int buffer = 0;
    semaphore empty = 1;
    semaphore full = 0;
    semaphore mutex_on_buffer = 1; 
       
    void Producent(){
        int data = SomeCoplexOperation();
        down(&empty);
        down(&mutex_on_buffer);        
        buffer = data;
        up(&mutex_on_buffer);                
        up(&full);
    }

    void Consumer() {
        down(&full);
        down(&mutex_on_buffer);        
        printf("%i\n", buffer);
        up(&mutex_on_buffer);                
        up(&empty);
    }
\end{verbatim}
\end{e}
