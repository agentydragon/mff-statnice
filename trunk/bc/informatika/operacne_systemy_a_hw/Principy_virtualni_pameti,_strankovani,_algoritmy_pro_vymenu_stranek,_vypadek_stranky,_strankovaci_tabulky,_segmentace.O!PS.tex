\subsection{Principy virtuální pamìti, stránkování, algoritmy pro výmìnu stránek, výpadek stránky, stránkovací tabulky, segmentace}

Kvalitní popis stránkování je také tady -- \url{http://wiki.osdev.org/Paging} (na téže stránce je i popis interruption for dummies -- \url{http://wiki.osdev.org/Interrupts})

\subsubsection*{Virtuální pamì}

\obrazekvpravominipage{informatika/operacne_systemy_a_hw/obrazky/virtual-memory.png}{Virtuál\-ní
pamì}{fig:virpamet}{0.15}{0.8}{

Virtuální pamì zpùsob správy operaèní pamìti poèítaèe, který umožòuje pøedložit bìžícímu procesu adresní prostor pamìti, který je uspoøádán jinak nebo je dokonce vìtší, než je fyzicky pøipojená operaèní pamì RAM. Z tohoto dùvodu procesor rozlišuje mezi virtuálními adresami (pracují s nimi strojové instrukce, resp. bìžící proces) a fyzickými adresami pamìti (odkazují na konkrétní adresové buòky pamìti RAM). Pøevod mezi virtuální a fyzickou adresou je zajišován samotným procesorem v MMU (je nutná hardwarová podpora) nebo samostatným obvodem. 
\\\\
Šlo
by to bez HW podpory? Jistì že ano VM to tak dìlají, nicménì rychlost není
nijak osòující, proto se do novych strojù už pøidává jejich HW podpora (??
ovìøit).
\begin{pitemize}
        \item Umožòuje sdílení pamìti (operaèním systémem)
        \item Vzájemná ochrana programù (v souèasnosti je dùležitìjší ochrana dat než využití
principu lokalit), tzn. to aby jeden program nepøepisoval druhému programu jeho
data a tak.
        \item Každý bìžící program pracuje se \textbf{svým} virtuálním adresním prostorem
\end{pitemize}
Existují dvì základní metody implementace virtuální pamìti – stránkování a segmentace.
}

\subsubsection*{Stránkování}
Pøi stránkování je pamì rozdìlena na vìtší úseky stejné velikosti, které se nazývají stránky. Správa virtuální pamìti rozhoduje samostatnì o tom, která pamìová stránka bude zavedena do vnitøní pamìti a která bude odložena do odkládacího prostoru (swapu).
\\\\
Podporované všemi velkými CPU a OS, jednorozmìrný VAP (virtuální adresní
prostor).\begin{pitemize}
\item VAP rozdìlen na stránky (velikost je mocnina 2), FAP na rámce (úseky stejné délky)
\item \textbf{pøevod stránkovací tabulkou}  - každý proces má svojí, pøíznak existence mapování (v.stránka není v FAP $\rightarrow$ událost "výpadek stránky" $\rightarrow$ synchronní pøerušení) umístìna v fyzické pamìti
\par \begin{center}\includegraphics[width=5cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani1_new.png}\end{center}
\item umožnuje \emph{oddìlené VAP} i \emph{sdílenou pamì} - mapování virtuální stránky 2 procesù na jednu fyzickou
\item OS mìní tabulky stránek zmìnou PTBR (Page Table Base Register) - PTBR obsahuje
bázovou adresu tabulky stránek procesu
\item Pøíklad: položka stránkovací tabulky Intel IA32 (= x86) $\rightarrow$ její struktura je závislá na architektuøe CPU
\par \begin{center} \includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-polozka.png} \end{center}
\item \textbf{víceúrovòové stránkování} (napø. kvùli velikosti - jedna tabulka
je už moc velká =\textgreater pomalá)
\par \begin{center} \includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani2_new.png} \end{center}
\item \textbf{TLB (Translation Lookaside Buffer)} - asociativní pamì sloužící na rychlé  mapování virtuální stránky na fyzickou, vyhledává se v ní paralelnì, typicky ma 128-256 položek, využívá princip prostorové lokality programù (vìtšina programù provádí velký poèet pøístupù k malému
poètu stránek)
umístìva vìtšinou v L1 nebo L2 cache na procesoru
\par 
\includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-tlb-schema.png}
%\caption{~~~}
\includegraphics[width=5cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-tlb.png}
 
\par ...\textbf{0-úrovòové stránkování} - procesor hledá pouze TLB, zbytek
øeší OS (oblíbené u 64-bitových CPU - UltraSPARC III)
\item \textbf{inverzní stránkování} (napø. když FAP je menší než VAP, 64-bitové CPU - IA-64 = UtraSPARC, PowerPC)
- inverzní stránkovací tabulka (IPT) nad rámci (nikoliv stránkami) spoleèná
pro všechny procesy, pro vyhledávání se používá hashovací tabulka\par \begin{center} \includegraphics[width=10cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-inv_new.png} \end{center}
\end{pitemize}

\begin{obecne}{Akce vykonávané pøi výpadku stránky:}
\begin{pitemize}
\item výjimka procesoru
\item uložit stav CPU (kontext)
\item zjistit VA
\item kontrola platnosti adresy a práv
\item nalezení vhodného rámce
\item zrušit mapování na nalezený rámec
\item pokud je vyhazovaný rámec vyhazován, spustit ukládání na disk
\item naèíst z disku požadovanou stránku do rámce
\item zavést mapování
\item obnovit kontext
\end{pitemize}
\end{obecne}

\begin{obecne}{Pøi implementaci stránkování je nutno brat v úvahu:}
\begin{pitemize}
    \item \emph{znovuspuštìní instrukce} --- je potøeba aby procesor po výpadku zkusil pøístup do pamìti znova. dnes umí všechny CPU, napø. 68xxx - problémy (pøerušení v pùlce instrukce)
    \item \emph{sdílení stránek} --- jednomu rámci odp. víc stránek $\rightarrow$ pokud s ním nìco dìlám, týká se to všech stránek! musím vše ost. odmapovat. musím si pamatovat mapování pro každý rámec - obrácené tabulky.
\item \emph{velikost stránek} \begin{pitemize} \item velké stránky $\rightarrow$ fragmentace
\item malé stránky $\rightarrow$ mnoho registrù, zvyšuje cenu výpoètù a zpomaluje
chod
\item optimum 1-4kB -- 4kB se používají kvuli jednoduchému pøevodu
na fyzickou adresu pomocí substituce (DRAM mely temer vzdy na cipu N øádku
x 4096 sloupcu \footnote{doporucuju precist
\url{http://www.gamedeception.net/threads/212-The-Importance-of-the-4KB-Page-Boundary}}) a protoze pro 32 bitovej adresovej prostor, zbyvalo 20 bitu adresy pro preklad, coz je na dvou urovnovy strankovaci tabulky - kazda na 10 bitu, 64bit procesory umožòují pagesize až 1GB 
\end{pitemize}
    \item \emph{odstranìní položky z TLB pøi rušení mapování} --- nestaèí zmìnit tabulky, musí se vyhodit i z TLB (kde to mùže, ale nemusí být). problém - u multiprocesorù má každá CPU vlastní TLB, tabulky jsou sdílené $\rightarrow$ CPU pøi rušení mapování musí poslat interrupt s rozkazem ke smazání všem (i sobì), poèkat na potvrzení akce od všech.
\end{pitemize}
\end{obecne}
\begin{e}{Pøíklad}{0}{0}
Uvažujte procesor, který podporuje stránkovani, má dvouúrovnove stránkovaci tabulky, velikost virtuální i fyzické adresy 32 bitu, velikost stránky 4 kB. Nakreslete formát strankovací tabulky (položky potøebné pro pøeklad adresy i typické další pøíznakové bity,
nezadané detaily rozumne zvolte) a v nem ilustrujte, jak se prelozi virtuálni adresa 12345678h
(nezadané konstanty tvoricí konkrétní obsah tabulky opet rozumne zvolte).
Pozn.: h nakonci znamená že je èíslo v hex (assembler)
\end{e}

\subsubsection*{Algoritmy pro výmìnu stránek (výbìr obìti)}
\begin{pitemize}
\item \textbf{Optimální stránka} (v okamžiku výpadku stránky vybírám stránku, na níž se pøistoupí za nejvìtší poèet instrukcí) - nelze implementovat
\item \textbf{\underline{NRU}} (Not Recently Used) - každá stránka má pøíznaky Accessed a Dirty (typicky implementovatelné v HW, možno simulovat SW); jednou za èas se smažou všechna A; pøi výpadku rozdìlím stránky podle A,D a vyberu stránku z nejnižší (0,1..4) neprázdné tøídy:
\par \begin{center}
\begin{tabular}{|c|c|c|}
\hline
& A & D \\
\hline
0 & 0 & 0 \\
\hline
1 & 0 & 1 \\
\hline
2 & 1 & 0 \\
\hline
3 & 1 & 1 \\
\hline
\end{tabular}
\end{center}
\item \textbf{\underline{FIFO}} - vyhodit nejdéle namapovanou stránku - vykazuje anomálie - Belady (zvìtšení poètu výpadkù stránky, když zvýšíme poèet stránek v pamìti), druhá šance (úprava FIFO; pokud A=1, zaøadím na konec FIFO... nevykazuje anomálie)
\item \textbf{Hodiny} - modifikace druhé šance: kruhový zoznam stránek + iterátor na ukazující na nejstarší stránku v zoznamu. Pøi výpadku (a neexistenci volého rámce) se zjistí, jestli má *iterator nastavený pøíznak Accessed. Jestli ne, tato stránka bude nahrazena - v opaèném pøípadì se Accessed pøíznak zruší a iterator++. Toto se opakuje, dokud nedojde k výmìnì\dots
\item \textbf{LRU} (Least Recently Used) - èasto používané stránky v posledním krátkém èasovém úšeku budou znovu použity, èítaè použití stránek, možné implementovat v HW
\item \textbf{NFU} (Not Frequently Used) - SW simulace LRU, SW èítaè ke každé stránce; jednou za èas projdu všechna A a pøiètu je k odpovídajícím èítaèùm; vybírám stránku s nejnižším èítaèem; nezapomíná - je možná modifikace se stárnutím èítaèe
\end{pitemize}

\subsubsection*{\sout{Segmentace} (už není v požadavcích)}
dnes pouze Intel IA-32, dvojrozmìrný VAP
\begin{pitemize}
\item rozdìlení programu na segmenty (napr. podle èástí s rùznými vlastnostmi - kód, data, zásobníky\dots), rùzné délky segmentù, ktoré mùžou mìnit svoji délku za bìhu
\item VAP dvourozmìrný (segment, offset), FAP jednorozmìrný (vyzerá jako pøi spojitém pridìlování pamìti)
\item segmentová pøevodní tabulka (VA se skládá ze dvou èastí S:D, v tabulce se najde adresa segmentu S\dots k této adrese se poté pøiète D, co je umístnìní adresy v FA), pøíznak existence mapování
\item pøi výpadku je nutné mìnit celý segment (ty mohou být velké), je možné segmenty sesypat - ale nelze mít segment vìtší než FAP
\end{pitemize}

Segmentaci je možné kombinovat se stránkováním (odstraòuje nevýhody segmentace, neprovádí se výpadky segmentù):
\par \begin{center}\includegraphics[width=12cm]{informatika/operacne_systemy_a_hw/obrazky/segmentace-a-strankovani.png}\end{center}

\begin{reportN}{Bednárek}
Tøeba mì pøekvapila Bednákova otázka u jednoúrovòovýho stránkování, když se zeptal, co z toho dìlá OS a co procesor (jako co je dìláno hardwareovì a co softwareovì).
\end{reportN}
\begin{reportN}{Bulej}
Strankovaci tabulku ma kazdy proces vlastni -> ochrana pameti, nemuze pristoupit na cizi stranky (mozna ze to v materialech ke statnicim je, ale ja to z nich nepochopil...)
\end{reportN}
\begin{reportN}{Skopal}
Nejdriv jsem popsal k cemu to je a potom princip. Chtel popsat postup toho co se deje, kdyz se hleda nejaky pointer. Co dela HW, co OS. Pak se zeptal jestli by slo udelat strankovani bez HW podpory (coz rozumne nejde, muselo by se to resit i v prekladacich a bylo by to nefektivni). Pak se zeptal na algoritmy vyhazovani stranek. Popsal jsem FIFO a NRU a to mu stacilo. Na segmentaci nastesti nedoslo.
Celkove velmi prijemne zkouseni. V zasade se spokojil s principy a nestoural moc do detailu.
\end{reportN}
\begin{reportN}{Kofron}
klasika, preèo, kde, ako ... preèo to funguje, èo sa robí pri výpadku stránky, preèo dve inštancie jedného programu nelezú do kapusty aj keï pracujú s rovnakými virtuálnymi adresami (každý má vlastnú str. tabu¾ku), tvar adresy, prevody...


každý proces má vlastní tabulku, její adresa v registru
\end{reportN}
\begin{reportN}{IOI 21. 6. 2011}
Daný procesor používá 32-bitovou architekturu a dvouúrovòové stránkování.
Instrukce MOV[0x12345678], EAX zapisuje obsah registru EAX na adresu 0x12345678.
Popište, jaká operace (pøístupy do registrù a podobnì) vykonává pøi provádìní této instrukce procesor a jak pøi tom spolupracuje operaèní systém. Rozeberte všechny možné (z hlediska naplnìní stránkovacích tabulek) pøípady, nepopisujte strategie výmìny stránek.
\end{reportN}
\begin{e}{Øešení:}{0}{od stevese}
pokud tomu trochu víc rozumíš, tak za tím, stejnì jako já, hledáš složitìjší otázku než ve skuteènosti je :-) Napíšu to v bodech (ve skuteènosti jsem to rozepisoval trochu víc.).
\\
\\- procesor se podívá na registr PC, vyzvedne další instrukci (tzv. fetch fáze)
\\- instrukce je dekódována v øadièi (tzv. decode fáze)
\\- øadiè podle kódu instrukce nastaví vodièe na datové cestì
\\- vykonává se instrukce
\\- registr PC += velikost instrukce
\\- goto 1
\\\\
bìhem toho, kdykoliv se pøistupuje do pamìti, mùže vzniknout page-fault (naèítání instrukce a potom ta adresa u instr. mov). U toho jsem popsal jak stránkování funguje. Že je typicky víceúrovòové, nejvyšší úroveò v nìjakém registru nebo minimálnì nemapované pamìti. Že pøi pøístupu str. tabulku další úrovnì mùže vzniknout další page-fault, co to je TLB atd. atd. A k tý komunikaci s OS: když vznikne page-fault je vyvolané pøerušení a obsluha je pøedaná obslužné rutinnì OS. Nìkterý procesory to dìlají u page-faultu ve stránkovací tabulce (x86 myslím), nìkterý už u page-faultu v TLB (urèitì MIPS) -- takže si potom OS mùže vybírat, jak mìnit stránky v samotné TLB.

Samotného mì zrovna tyhle vìci zajímají, takže jsem si pøed státnicema pøeèetl Tanenbauma: Operating Systems a Pattersona: Computers Design: Hardware to software interface. Je to urèitì overkill, ale pokud budeš mít prolistovaný tyhle dvì knihy, tak tì tam imho témìø urèitì nic nemùže pøekvapit.
\end{e}

\begin{e}{Report}{0}{IOI 21.6.2011}
Virtualni pamet
\\page, page fault, TLB, implementace v OS/HW, jak presne funguje TLB na
konkretnim pripadu. 
\end{e}
\begin{reportN}{IP 9. 9. 2011}
Byl zadán podobný zdroják :
\begin{verbatim}
    void main()
    {
        void * P = malloc (1024);
        void * N = malloc (256);
    }
\end{verbatim}    
a) $P = 0x0AFFCAF0$, $N = 0x0AFFC970$. Dotaz byl jestli by se Mezi P a N vešel ještì jeden malloc o velikosti
128B.
\\
b) NSD(P,N) = 16 ... popište èím by to mohlo být a proè.
\\
c) Kdyz program cetl prvni byte z toho 256-bytoveho bloku, tak se na
adresove sbernici u pametovych modulu pracovalo s adresou 0x61C74970.
Jak jsou velke stranky? Hodnoty P a N stejné jako v a).
\\\\
Urèitì teda radím nepanikaøit jak už tu zaznìlo, když nìco víte hned to tam napsat (tøeba u toho stránkování jsem alespoò zhruba popsal princip stránkování a myslím že to mì zachránilo, protože jinak jsem to mìl tak všelijak.)
\end{reportN}

\begin{e}{Øešení:}{0}{0}
a) rozborem pøípadù
\\
b) protože 4B je stránka nebo je to náhoda
\\
c) 
\end{e}

\begin{reportN}{Yaghob} mel ruzné dotazy, jako proc je stránka veliká zrovna 4kB, jak je to se stránkováním na 64-bitových procesorech 
\end{reportN}
