\subsection{Principy virtuální pamìti, stránkování, algoritmy pro výmìnu stránek, výpadek stránky, stránkovací tabulky\sout{, segmentace}}

Kvalitní popis stránkování je také tady -- \url{http://wiki.osdev.org/Paging} (na téže stránce je i popis interruption for dummies -- \url{http://wiki.osdev.org/Interrupts})

\subsubsection*{Virtuální pamì}

\obrazekvpravominipage{informatika/operacne_systemy_a_hw/obrazky/virtual-memory.png}{Virtuál\-ní
pamì}{fig:virpamet}{0.15}{0.8}{

Virtuální pamì zpùsob správy operaèní pamìti poèítaèe, který umožòuje pøedložit bìžícímu procesu adresní prostor pamìti, který je uspoøádán jinak nebo je dokonce vìtší, než je fyzicky pøipojená operaèní pamì RAM. Z tohoto dùvodu procesor rozlišuje mezi virtuálními adresami (pracují s nimi strojové instrukce, resp. bìžící proces) a fyzickými adresami pamìti (odkazují na konkrétní adresové buòky pamìti RAM). Pøevod mezi virtuální a fyzickou adresou je zajišován samotným procesorem v MMU (je nutná hardwarová podpora) nebo samostatným obvodem. 
\\\\
Šlo
by to bez HW podpory? Jistì že ano VM to tak dìlají, nicménì rychlost není
nijak osòující, proto se do novych strojù už pøidává jejich HW podpora (??
ovìøit).
\begin{pitemize}
        \item Umožòuje sdílení pamìti (operaèním systémem)
        \item Vzájemná ochrana programù (v souèasnosti je dùležitìjší ochrana dat než využití
principu lokalit), tzn. to aby jeden program nepøepisoval druhému programu jeho
data a tak.
        \item Každý bìžící program pracuje se \textbf{svým} virtuálním adresním prostorem
\end{pitemize}
Existují dvì základní metody implementace virtuální pamìti – stránkování a segmentace.
}

\subsubsection*{Stránkování}
Pøi stránkování je pamì rozdìlena na vìtší úseky stejné velikosti, které se nazývají stránky. Správa virtuální pamìti rozhoduje samostatnì o tom, která pamìová stránka bude zavedena do vnitøní pamìti a která bude odložena do odkládacího prostoru (swapu).
\\\\
Podporované všemi velkými CPU a OS, jednorozmìrný VAP (virtuální adresní
prostor).\begin{pitemize}
\item VAP rozdìlen na stránky (velikost je mocnina 2), FAP na rámce (stejné délky jako stránky\footnote{zdroj: \url{http://people.csail.mit.edu/rinard/osnotes/h9.html}})
\item \textbf{pøevod stránkovací tabulkou}  - každý proces má svojí, pøíznak existence mapování (v.stránka není v FAP $\rightarrow$ událost "výpadek stránky" $\rightarrow$ synchronní pøerušení) umístìna v fyzické pamìti
\par \begin{center}\includegraphics[width=5cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani1_new.png}\end{center}
\item umožnuje \emph{oddìlené VAP} i \emph{sdílenou pamì} - mapování virtuální stránky 2 procesù na jednu fyzickou (copy-on-write)
\item OS mìní tabulky stránek zmìnou PTBR (Page Table Base Register) - PTBR obsahuje
bázovou adresu tabulky stránek procesu
\item Pøíklad: 32bitová položka stránkovací tabulky Intel IA32 (= x86) $\rightarrow$ její struktura je závislá na architektuøe CPU
\par \begin{center} \includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-polozka.png} \end{center}
\item \textbf{víceúrovòové stránkování} (napø. kvùli velikosti - jedna tabulka
je už moc velká =\textgreater pomalá)
\par \begin{center} \includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani2_new.png} \end{center}
\item \textbf{TLB (Translation Lookaside Buffer)} - asociativní pamì sloužící na rychlé  mapování virtuální stránky na fyzickou, vyhledává se v ní paralelnì, typicky ma 128-256 položek, využívá princip prostorové lokality programù (vìtšina programù provádí velký poèet pøístupù k malému
poètu stránek)
umístìna vìtšinou  na procesoru, mùže obsahovat dirty bit (urèuje jestli bylo na stránku zapisováno)
\par 
\includegraphics[width=6cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-tlb-schema.png}
%\caption{~~~}
\includegraphics[width=5cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-tlb.png}
 
\par ...\textbf{0-úrovòové stránkování} - procesor hledá pouze TLB, zbytek
øeší OS (oblíbené u 64-bitových CPU - UltraSPARC III)
\item \textbf{inverzní stránkování} (napø. když FAP je menší než VAP, 64-bitové CPU - IA-64 = UtraSPARC, PowerPC)
- inverzní stránkovací tabulka (IPT) nad rámci (nikoliv stránkami) spoleèná
pro všechny procesy, pro vyhledávání se používá hashovací tabulka\par \begin{center} \includegraphics[width=10cm]{informatika/operacne_systemy_a_hw/obrazky/strankovani-inv_new.png} \end{center}
\end{pitemize}

\begin{obecne}{Akce vykonávané pøi výpadku stránky:}
\begin{pitemize}
\item výjimka procesoru
\item uložit stav CPU (kontext)
\item zjistit VA
\item kontrola platnosti adresy a práv
\item nalezení vhodného rámce
\item zrušit mapování na nalezený rámec
(obì)\item pokud je vyhazovaný rámec vyhazován, spustit ukládání na disk
\item naèíst z disku požadovanou stránku do rámce
\item zavést mapování
\item obnovit kontext
\end{pitemize}
\end{obecne}

\begin{obecne}{Pøi implementaci stránkování je nutno brat v úvahu:}
\begin{pitemize}
    \item \emph{znovuspuštìní instrukce} --- je potøeba aby procesor po výpadku zkusil pøístup do pamìti znova. dnes umí všechny CPU, napø. 68xxx - problémy (pøerušení v pùlce instrukce)
    \item \emph{sdílení stránek} --- jednomu rámci odp. víc stránek $\rightarrow$ pokud s ním nìco dìlám, týká se to všech stránek! musím vše ost. odmapovat. musím si pamatovat mapování pro každý rámec - obrácené tabulky (nebo copy-on-write).
\item \emph{velikost stránek} \begin{pitemize} \item velké stránky $\rightarrow$ fragmentace
\item malé stránky $\rightarrow$ mnoho registrù, zvyšuje cenu výpoètù a zpomaluje
chod
\item optimum 1-4kB, 64bit procesory umožòují pagesize až 1GB 
\item 4kB se používají kvuli jednoduchému pøevodu
na fyzickou adresu pomocí substituce (DRAM mely temer vzdy na cipu N øádku
x 4096 sloupcu \footnote{doporucuju precist
\url{http://www.gamedeception.net/threads/212-The-Importance-of-the-4KB-Page-Boundary}}) a protoze pro 32 bitovej adresovej prostor, zbyvalo 20 bitu adresy pro preklad, coz je na dvou urovnovy strankovaci tabulky - kazda na 10 bitu
\item Pøíklad: 32bit adresní prostorem popíšeme $2^{32}=4~294~967~296B=4GB$,
je-li velikost stránky 4kB poøebujeme na adresaci ve stránce 12bitù ($2^{12}=4~096B=4kB$)
a na stránkovací tabulku nám zbývá 20bitù (což je max. $2^{20}=1~048~576$ záznamù) \end{pitemize}
    \item \emph{odstranìní položky z TLB pøi rušení mapování} --- nestaèí zmìnit tabulky, musí se vyhodit i z TLB (kde to mùže, ale nemusí být). problém - u multiprocesorù má každá CPU vlastní TLB, tabulky jsou sdílené $\rightarrow$ CPU pøi rušení mapování musí poslat interrupt s rozkazem ke smazání všem (i sobì), poèkat na potvrzení akce od všech.
\end{pitemize}
\end{obecne}
\begin{e}{Pøíklad}{0}{0}
Uvažujte procesor, který podporuje stránkovani, má dvouúrovnove stránkovaci tabulky, velikost virtuální i fyzické adresy 32 bitu, velikost stránky 4 kB. Nakreslete formát strankovací tabulky (položky potøebné pro pøeklad adresy i typické další pøíznakové bity,
nezadané detaily rozumne zvolte) a v nem ilustrujte, jak se prelozi virtuálni adresa 12345678h
(nezadané konstanty tvoricí konkrétní obsah tabulky opet rozumne zvolte).
Pozn.: h nakonci znamená že je èíslo v hex (v assembleru)
\end{e}

\subsubsection*{Algoritmy pro výmìnu stránek (výbìr obìti)}
\begin{pitemize}
\item \textbf{Optimální stránka} (v okamžiku výpadku stránky vybírám stránku, na níž se pøistoupí za nejvìtší poèet instrukcí) - nelze implementovat
\item \textbf{\underline{NRU}} (Not Recently Used) - každá stránka má pøíznaky Accessed a Dirty (typicky implementovatelné v HW, možno simulovat SW); jednou za èas se smažou všechna A; pøi výpadku rozdìlím stránky podle A,D a vyberu stránku z nejnižší (0,1..4) neprázdné tøídy:
\par \begin{center}
\begin{tabular}{|c|c|c|}
\hline
& A & D \\
\hline
0 & 0 & 0 \\
\hline
1 & 0 & 1 \\
\hline
2 & 1 & 0 \\
\hline
3 & 1 & 1 \\
\hline
\end{tabular}
\end{center}
\item \textbf{\underline{FIFO}} - vyhodit nejdéle namapovanou stránku - vykazuje anomálie - Belady (zvìtšení poètu výpadkù stránky, když zvýšíme poèet stránek v pamìti), druhá šance (úprava FIFO; pokud A=1, zaøadím na konec FIFO... nevykazuje anomálie)
\item \textbf{Hodiny} - modifikace druhé šance: kruhový zoznam stránek + iterátor na ukazující na nejstarší stránku v zoznamu. Pøi výpadku (a neexistenci volého rámce) se zjistí, jestli má *iterator nastavený pøíznak Accessed. Jestli ne, tato stránka bude nahrazena - v opaèném pøípadì se Accessed pøíznak zruší a iterator++. Toto se opakuje, dokud nedojde k výmìnì\dots
\item \textbf{LRU} (Least Recently Used) - èasto používané stránky v posledním krátkém èasovém úšeku budou znovu použity, èítaè použití stránek, možné implementovat v HW
\item \textbf{NFU} (Not Frequently Used) - SW simulace LRU, SW èítaè ke každé stránce; jednou za èas projdu všechna A a pøiètu je k odpovídajícím èítaèùm; vybírám stránku s nejnižším èítaèem; nezapomíná - je možná modifikace se stárnutím èítaèe
\end{pitemize}

\begin{e}{Horní odhad poètu výpadkù stránek}{0}{asi není nutné
ke státnicím znát dokonale}
\textit{Fakt:}
Nejvyssi uroven strankovacich tabulek je vzdy v nestrankovana pameti.
\\
\textit{Pozorovani 1:}
Data se presouvaji, tudiz velikost pameti, se kterou se pracuje je 2-krat velikost dat. Z jedne poloviny velikosti dat se data ctou, do druhe se zapisuji.
\\
\textit{Pozorovani 2:}
Vypadek stranky muze nastat na ctyrech mistech.

$\bullet$ Vykonavana instrukce nemusi byt v pameti.

$\bullet$ Pamet, ze ktere se ctou data nemusi byt v pameti.

$\bullet$ Pamet, kam se zapisuje nemusi byt v pameti.

$\bullet$ Strankovaci tabulky druhe a vyssi urovne nemusi byt v pameti. 
\\\\
\textit{Tvrzeni:}
Pri (K-1)-urovnovem strankovani je maximalni pocet vypadku roven poctu vypadku pri K-urovnovem strankovani bez vypadku v druhe urovni strankovani. 
\\\\\textit{Pøíklad:} jaky je maximalni pocet vypadku? 2B instrukce, 8kB dat, 4kB stranka, 3 urovne strankovani, tabulky maji 1024 polozek.
\\\\\footnotesize
Zajima nas maximalni pocet stranek, tudiz pocitame worst-case. Samotna instrukce je na 2B, muze se tedy vyskytnout na rozhrani 2 stranek a zpusobit dva vypadky. Ve treti urovni strankovani na kazdou tuto stranku ukazuje pointer. Pro dve stranky muze tato informace byt opet na rozhrani dvou stranek a tudiz zpusobit dalsi 2 vypadky stranky. Pro tyto dve stranky je pak v druhe urovni totez, tudiz dalsi dva vypadky jsou mozne v druhe urovni strankovani. Pro tyto dve stranky je pak v prvni urovni totez, ale tam jsou dle Faktu udaje vzdy nestrankovane. Samotna instrukce tak zpusobi az 2+2+2=6 vypadku. Podle Tvrzeni by pri dvouurovnovem strankovani bylo na instrukci maximalne 2+2=4 vypadku a pri jednourovnovem pouze 2 vypadky.

Nyni pocitame data. Podle Pozorovani 1 a 2 je zrejme, ze staci spocitat pouze vypadky pro jednu datovou cast. U druhe bude maximalni pocet vypadku stejny a staci tedy vynasobit pocet pro jedny data dvema. Takze 8kb dat lze nasklad maximalne do tri 4kb stranek. To jsou tri vypadky. Tyto tri stranky jsou ve treti urovni referencovany maximalne na rozhrani dvou stranek a tudiz zde mohou zpusobit 2 vypadky. Stejne jako u instrukce pak v druhe urovni mohou nastat take 2 vypadky. Celkem tedy na tato data pripadne az 3+2+2=7 vypadku stranek. Celkem na data tedy az 14 vypadku pri triurovnovem strankovani. Opet podle Tvrzeni je pocet vypadku pri dvou urovnich strankovani maximalne 10 a pri jedne urovni 6.
Celkovy pocet vypadku je tedy az 20 pro tri urovne strankovani, 14 pri dvou urovnich a 8 pri jedne urovni. 
\\\\    
\url{http://mff.lokiware.info/ZakladyOperacnichSystemu/ZkouskaLS2008?v=1aug}
\\
\url{http://s0cketka.blogspot.com/2006/05/zaklady-zakladu-operacnich-systemu.html}
\end{e}

\subsubsection*{\sout{Segmentace} (už není v požadavcích)}
dnes pouze Intel IA-32, dvojrozmìrný VAP
\begin{pitemize}
\item rozdìlení programu na segmenty (napr. podle èástí s rùznými vlastnostmi - kód, data, zásobníky\dots), rùzné délky segmentù, ktoré mùžou mìnit svoji délku za bìhu
\item VAP dvourozmìrný (segment, offset), FAP jednorozmìrný (vyzerá jako pøi spojitém pridìlování pamìti)
\item segmentová pøevodní tabulka (VA se skládá ze dvou èastí S:D, v tabulce se najde adresa segmentu S\dots k této adrese se poté pøiète D, co je umístnìní adresy v FA), pøíznak existence mapování
\item pøi výpadku je nutné mìnit celý segment (ty mohou být velké), je možné segmenty sesypat - ale nelze mít segment vìtší než FAP
\end{pitemize}

Segmentaci je možné kombinovat se stránkováním (odstraòuje nevýhody segmentace, neprovádí se výpadky segmentù):
\par \begin{center}\includegraphics[width=12cm]{informatika/operacne_systemy_a_hw/obrazky/segmentace-a-strankovani.png}\end{center}

\subsubsection*{Tahák na pøevod hex do dec a bin}
\begin{tabular}{l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
DECIMAL & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15\\
HEX & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & A & B & C & D & E & F\\
BINARY & 0000 & 0001 & 0010 & 0011 & 0100 & 0101 & 0110 & 0111 & 1000 &  1001 & 1010 & 1011 & 1100 & 1101 & 1110 & 1111
\end{tabular}
\\\\\\
\begin{reportN}{Bednárek}
Tøeba mì pøekvapila Bednákova otázka u jednoúrovòovýho stránkování, když se zeptal, co z toho dìlá OS a co procesor (jako co je dìláno hardwareovì a co softwareovì).
\end{reportN}
\begin{reportN}{Bulej}
Strankovaci tabulku ma kazdy proces vlastni -> ochrana pameti, nemuze pristoupit na cizi stranky (mozna ze to v materialech ke statnicim je, ale ja to z nich nepochopil...)
\end{reportN}
\begin{reportN}{Skopal}
Nejdriv jsem popsal k cemu to je a potom princip. Chtel popsat postup toho co se deje, kdyz se hleda nejaky pointer. Co dela HW, co OS. Pak se zeptal jestli by slo udelat strankovani bez HW podpory (coz rozumne nejde, muselo by se to resit i v prekladacich a bylo by to nefektivni). Pak se zeptal na algoritmy vyhazovani stranek. Popsal jsem FIFO a NRU a to mu stacilo. Na segmentaci nastesti nedoslo.
Celkove velmi prijemne zkouseni. V zasade se spokojil s principy a nestoural moc do detailu.
\end{reportN}
\begin{reportN}{Kofron}
klasika, preèo, kde, ako ... preèo to funguje, èo sa robí pri výpadku stránky, preèo dve inštancie jedného programu nelezú do kapusty aj keï pracujú s rovnakými virtuálnymi adresami (každý má vlastnú str. tabu¾ku), tvar adresy, prevody...


každý proces má vlastní tabulku, její adresa v registru
\end{reportN}
\begin{reportN}{IOI 21. 6. 2011}
Daný procesor používá 32-bitovou architekturu a dvouúrovòové stránkování.
Instrukce MOV[0x12345678], EAX zapisuje obsah registru EAX na adresu 0x12345678.
Popište, jaká operace (pøístupy do registrù a podobnì) vykonává pøi provádìní této instrukce procesor a jak pøi tom spolupracuje operaèní systém. Rozeberte všechny možné (z hlediska naplnìní stránkovacích tabulek) pøípady, nepopisujte strategie výmìny stránek.
\end{reportN}
\begin{e}{Øešení:}{0}{od stevese}
pokud tomu trochu víc rozumíš, tak za tím, stejnì jako já, hledáš složitìjší otázku než ve skuteènosti je :-) Napíšu to v bodech (ve skuteènosti jsem to rozepisoval trochu víc.).
\\
\\- procesor se podívá na registr PC, vyzvedne další instrukci (tzv. fetch fáze)
\\- instrukce je dekódována v øadièi (tzv. decode fáze)
\\- øadiè podle kódu instrukce nastaví vodièe na datové cestì
\\- vykonává se instrukce
\\- registr PC += velikost instrukce
\\- goto 1
\\\\
bìhem toho, kdykoliv se pøistupuje do pamìti, mùže vzniknout page-fault (naèítání instrukce a potom ta adresa u instr. mov). U toho jsem popsal jak stránkování funguje. Že je typicky víceúrovòové, nejvyšší úroveò v nìjakém registru nebo minimálnì nemapované pamìti. Že pøi pøístupu str. tabulku další úrovnì mùže vzniknout další page-fault, co to je TLB atd. atd. A k tý komunikaci s OS: když vznikne page-fault je vyvolané pøerušení a obsluha je pøedaná obslužné rutinnì OS. Nìkterý procesory to dìlají u page-faultu ve stránkovací tabulce (x86 myslím), nìkterý už u page-faultu v TLB (urèitì MIPS) -- takže si potom OS mùže vybírat, jak mìnit stránky v samotné TLB.

Samotného mì zrovna tyhle vìci zajímají, takže jsem si pøed státnicema pøeèetl Tanenbauma: Operating Systems a Pattersona: Computers Design: Hardware to software interface. Je to urèitì overkill, ale pokud budeš mít prolistovaný tyhle dvì knihy, tak tì tam imho témìø urèitì nic nemùže pøekvapit.
\end{e}

\begin{e}{Report}{0}{IOI 21.6.2011}
Virtualni pamet
\\page, page fault, TLB, implementace v OS/HW, jak presne funguje TLB na
konkretnim pripadu. 
\end{e}
\begin{reportN}{IP 9. 9. 2011}
Byl zadán podobný zdroják :
\begin{verbatim}
    void main()
    {
        void * P = malloc (1024);
        void * N = malloc (256);
    }
\end{verbatim}    
a) $P = 0x0AFFCAF0$, $N = 0x0AFFC970$. Dotaz byl jestli by se Mezi P a N vešel ještì jeden malloc o velikosti
128B.
\\
b) NSD(P,N) = 16 ... popište èím by to mohlo být a proè.
\\
c) Kdyz program cetl prvni byte z toho 256-bytoveho bloku, tak se na
adresove sbernici u pametovych modulu pracovalo s adresou 0x61C74970.
Jak jsou velke stranky? Hodnoty P a N stejné jako v a).
\\\\
Urèitì teda radím nepanikaøit jak už tu zaznìlo, když nìco víte hned to tam napsat (tøeba u toho stránkování jsem alespoò zhruba popsal princip stránkování a myslím že to mì zachránilo, protože jinak jsem to mìl tak všelijak.)
\end{reportN}

\begin{e}{Øešení:}{0}{0}
a) Nevejde. Mezi koncem $<N;N+0xff)$ a pocatkem bloku P je presne 0x80 =
128 B volneho prostoru. Spravce haldy ale prideluje trosku vice pameti,
nez o kolik jej zadame. Kazdy blok ma ve vetsine pripadu tzv. hlavicku,
kde je ulozena napr. informace o jeho velikosti a o tom, ze je obsazeny
(kdyz je volny, tak tam byvajy odkazy na predchudce ci naslednika ve
spojovem seznamu volnych bloku). Z ladicich duvodu muze byt pritomna
jeste paticka, aby se dalo poznat, ze se zapisuje za konec bloku.
Jelikoz se snazime do 128 B prostoru nacpat 128 B blok bez hlavicky, tak
se tam logicky nevejde, protoze prave na tu hlavicku neni misto.
\\
b) Podle meho nazoru se tak deje hlavne kvuli zjednoduseni implementace
spravce haldy a zkraceni jeho datovych struktur (zejmena hlavicek).
Spravce haldy (alespon ten ve Windows to dela) obvykle zaokrouhluji
velikost pozadovaneho bloku na nasobek osmi ci sestnacti (zalezi take na
architekture trosku). A pokud ty pridelene bloky (a jejich hlavicky)
zacinaji vzdy na adrese, jenz je nasobkem osmi resp. sestnacti, znamena
to, ze dolni 3 resp. 4 bity odkazu na tyto bloky v ramci struktur
spravce haldy lze vyuzit k jinym ucelum, napriklad na ukladani ruznych
priznaku. Pokud tedy mame napr. 32bitove adresy a spravce haldy
zarovnava na 16 bajtu, staci nam 28 bitu na zakodovani jednoho pointeru.
\\
c) Podle me staci porovnavat odzadu hodnotu te fyzicke adresy a hodnotu
pointeru N. Prvni bit, ktery se lisi, nam dava hint, kde by mohla koncit
offsetova cast virtualni adresy. Ale je to hint, nikoli logicka
platnost. Tady by to treba vyslo na 15 bitu, coz je u 32bitovych adres
ponekud nezvykle. Tedy asi okecat.
\end{e}

\begin{reportN}{Yaghob} mel ruzné dotazy, jako proc je stránka veliká zrovna 4kB, jak je to se stránkováním na 64-bitových procesorech 
\end{reportN}
