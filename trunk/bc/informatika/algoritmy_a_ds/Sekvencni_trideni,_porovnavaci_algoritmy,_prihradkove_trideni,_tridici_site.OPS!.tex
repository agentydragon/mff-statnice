\subsection{Sekvenèní tøídìní, porovnávací algoritmy, pøihrádkové tøídìní, tøídící sítì}

TODO: trochu víc formalismu by tu neškodilo, taky je potøeba sjednotit óèkovou notaci (zøejmì prosté nahrazení symbolu $O$ symbolem $\Theta$ by staèilo, ale chce to ovìøit).

\subsubsection*{Sekvenèní tøídìní a porovnávací algoritmy}

Pojmy \uv{sekvenèní tøídìní} a \uv{porovnávací algoritmy} mohou znamenat vlastnì cokoliv, take uvedu pár nejbìnìjších tøídících algoritmù a budu doufat, e to bude ke zkoušce staèit \texttt{:-(}. Zdrojem mi budi Wikipedie a kniha Algoritmy a programovací techniky Doc. P. Töpfera.

\bigskip

\begin{e}{Algoritmus}{0}{Selection sort, tøídìní vıbìrem}
Selection sort je jeden z nejjednodušších tøídích algoritmù. Jde o vnitøní tøídìní -- tedy celá posloupnost prvkù by mìla bıt v pamìti. Má èasovou sloitost $\Theta(n^2)$ a obecnì bıvá pomalejší ne insertion sort. Pracuje následovnì:

Udruje si mnoinu setøídìnıch prvkù na zaèátku posloupnosti (pole), která je na zaèátku prázdná a na konci pøedstavuje celé pole. Zbytek pole za setøídìnou mnoinou je neuspoøádanı. V jednom kroku vdy vybere jeden prvek a vloí ho do utøídìné èásti (kterou tím zvìtší o 1 a zároveò zmenší nesetøídìnou). Jeden krok algoritmu (kterıch je $n$ pro $n$ prvkù v kadém pøípadì) vypadá takto: 
\begin{penumerate}
    \item Najdi nejmenší prvek z nesetøídìného úseku.
    \item Vlo ho pøesnì za konec setøídìného úseku (a prvek co tam byl pùvodnì si s ním vymìní místo)
\end{penumerate}

Heapsort, kterı popíšu pozdìji, mùe bıt povaovanı za variantu selection sortu, protoe také vybírá minimum a zaèleòuje do setøídìné èásti.
\end{e}

\begin{e}{Algoritmus}{0}{Insertion sort, tøídìní vkládáním}
Insertion sort je také relativnì jednoduchı a na velké datové soubory neefektivní, ale jednoduchı na implementaci a rychlejší ne nejprimitivnìjší algoritmy bubble sort a selection sort. Navíc je efektivní pro data, která jsou u èásteènì pøedtøídìná -- v nejhorším pøípadì sice bìí v èase $O(n^2)$, ale v nejlepším pøípadì (úplné setøídìní dat) je lineární -- obecnì bìí v èase $O(n+d)$, kde $d$ je poèet inverzí ve tøídìné posloupnosti. Navíc je stabilní (zachovává poøadí prvkù se stejnım klíèem) a \uv{in-place}, tedy nepotøebuje ádné pomocné datové struktury. Proti selection sortu ale vìtšinou potøebuje více pøepisování (a to mùe u velkıch datovıch struktur vadit).

V jednom kroku vdy vezme nìjakı prvek (berou se po øadì od zaèátku pole), zapamatuje si jeho hodnotu, a dokud pøed ním jsou prvky s vìtším klíèem, posouvá je na pozici o 1 vìtší (èím vdy pøepíše následující, take pùvodní prvek se ztratí) a pokud narazí na prvek s menším klíèem, do za nìj napíše onen zapamatovanı prvek (a místo tam je, protoe celou cestu k nìmu posouval prvky). Algoritmus vypadá takto:
\begin{verbatim}
insert sort( array a ){
  for( i = 1; i < a.length - 1; ++i ){
    value = a[i];
    j = i-1;
    while( j >= 0 && a[j] > value ){ 
      a[j + 1] = a[j];
      j = j-1;
    }
    a[j+1] = value;
  }
}
\end{verbatim}

Jednou z variant insertion sortu je \emph{Shell sort}, kterı porovnává prvky ne vedle sebe, ale vzdálené o nìjakı poèet polí, kterı se postupnì zmenšuje. Mùe dosahovat sloitost $O(n^{3/2})$ a $O(n^{4/3})$. S jistımi úpravami se u nìj dá dosáhnout a $O(n\log^2 n)$. Jiné vylepšení je \emph{library sort}, kterı si pøi vkládání nechává mezery pro další prvky (podobnì jako v knihovnì nejsou polièky úplnì plné) -- ten mùe s velkou pravdìpodobností bìet v èase $O(n\log n)$, ale zase potøebuje vìtší pamìovı prostor.
\end{e}

\begin{e}{Algoritmus}{0}{Bubble sort, bublinkové tøídìní}
Bubble sort je velmi jednoduchı tøídící algoritmus (asi nejjednodušší na implementaci), s èasovou sloitostí $O(n^2)$. V nejlepším pøípadì (pro úplnì setøídìná data) mu ale staèí jen jeden prùchod, take $O(n)$. Vìtšinou ale bıvá pomalejší i ne insertion sort, take se na velké mnoiny dat nehodí.

Algoritmus prochází v jednom kroku celé pole a hledá pozice, kde se prvek s menším klíèem nachází bezprostøednì za prvkem s vìtším klíèem. Takovéto dva prvky pak vymìní. Kroky opakuje, dokud neprojde celé pole bez jediného prohození prvkù (nebo v \uv{tupìjší} variantì $n$-krát pro $n$ prvkù, protoe pak je zaruèeno, e posloupnost bude pro libovolné poøadí prvkù setøídìná -- ta má ale pak sloitost $O(n^2)$ v kadém pøípadì!).

Vylepšení algoritmu lze dosáhnout jednoduchou úvahou: nejvìtší prvek je u pøi prvním prùchodu polem odsunutı a na konec. To se samozøejmì opakuje pro kadı prùchod (ve druhém je pøedposlední na druhém místì od konce atp.), take lze prùchody postupnì zkracovat a konec pole u netestovat -- dosáhneme tím v prùmìru dvojnásobné rychlosti.

Variantou bubble sortu je \emph{shake sort} neboli \emph{cocktail sort}, kterı støídavì prochází posloupnost prvkù nejdøív od zaèátku a pak od konce (a pøitom provádí to samé jako bubble sort). Tím mùe v nìkterıch pøípadech o trochu tøídìní zrychlit -- pøíkladem budi posloupnost prvkù $(2,3,4,5,1)$, která potøebuje jen 1 prùchod cocktail-sortem tam a jeden zpìt, ale pro bubble-sort by potøebovala 4.

Dalším vylepšením bubble sortu je \emph{Comb sort}, kterı o nìco zvyšuje rychlost. Je zaloen na stejné myšlence jako shell sort -- tedy nejsou porovnávány prvky bezprostøednì za sebou, ale prvky posunuté o nìjakı ofset -- ten je na zaèátku roven délce posloupnosti, a postupnì se dìlí \uv{zkracovacím faktorem} (bìná hodnota $1.3$) a dosáhne jedné. Sloitost se pohybuje mezi $O(n^2)$ v nejhorším pøípadì a $O(n\log n)$ v nejlepším. V prùmìrném pøípadì jde stále o $O(n^2)$, ale s menší konstantou ne u bubble-sortu (TODO: tohle je potøeba set-sakra ovìøit ... opsané z nìmecké wiki a \uv{talk:Comb sort} na anglické, take fakt \uv{dùvìryhodné}).
\end{e}

\begin{e}{Algoritmus}{0}{Heap sort, tøídìní haldou}
Heapsort je také tøídící algoritmus zaloenı na porovnávání a myšlenkovì vychází ze selection sortu, ke kterému pøidává práci s haldou. Vìtšinou bıvá pro typická vstupní data pomalejší ne quicksort, ale zaruèuje èasovou sloitost $O(n\log n)$ i v nejhorším pøípadì. Jde o \uv{in-place} algoritmus (halda se mùe nacházet pøímo v nesetøídìné èásti pole), ale není \uv{stabilní}.

Algoritmus sám, máme-li vyøešené operace na haldì, je velice jednoduchı -- nejdøíve pro kadı prvek opakuje jeho vloení do haldy (take postupnì vytvoøí $n$-prvkovou haldu, která se s kadım krokem zvìtšuje o 1), pro implementaci haldy na zaèátku pole je vhodnı \uv{max-heap}, a potom opakuje odebrání maxima a jeho pøesun na volné místo hned za konci zmenšivší se haldy -- take od konce pole postupnì roste smìrem k zaèátku setøídìná posloupnost.

Upravenı heapsort s pouitím ternární haldy dosahuje o multiplikativní konstantu lepší vısledky, existuje i (prı :-)) sloitá varianta \emph{smoothsort}, která se blíí èasové sloitosti $O(n)$, pokud jsou data èásteènì pøedtøídìná -- heapsort toti pracuje pro libovolnou posloupnost v èase $O(n\log n)$.
\end{e}

\begin{e}{Algoritmus}{0}{Merge sort, tøídìní sléváním}
Dalším tøídícím algoritmem zaloenım na porovnávání prvkù je mergesort. Je stabilní, take zachovává poøadí dat se stejnım klíèem. Jde o pøíklad algoritmu typu \uv{rozdìl a panuj}, stejnì jako u níe popsaného quicksortu. Byl vynalezen Johnem Von Neumannem. Je zaloen na rozdìlení posloupnosti na dvì zhruba stejné poloviny, rekurzivním setøídìní a potom \uv{slévání} dvou ji setøídìnıch posloupností. Jeho èasová sloitost je $O(n\log n)$ i v nejhorším pøípadì, provádí vìtšinou ménì porovnání ne quicksort, má vìtší nároky na pamì v pøípadì rekurzivního volání (existuje ale i nerekurzivní verze), ale vìtšinou nepracuje na místì a potøebuje alokovat pamì pro vıstup setøídìnıch posloupností (i toto se dá odstranit, ale je to zbyteènì sloité a pøílišné zrychlení oproti pouití jiného algoritmu nepøinese). Jeho pøístup ho ale èiní ideálním k pouití na médiích se sekvenèním pøístupem k datùm (napø. pásky). Jde tedy pouít i ke tøídìní na vnìjší pamìti -- detaily viz sekce o databázích.

Postup práce je následující:
\begin{penumerate}
    \item Rozdìl nesetøídìnou posloupnost na dvì (zhruba) polovièní èásti    
    \item Pokud mají více ne jeden prvek, setøiï je rekurzivním zavoláním mergesortu (tj. pro kadou z nich pokraèuj od kroku 1 do konce algoritmu), jinak pokraèuj následujícím krokem.
    \item Slij dvì setøídìné posloupnosti do jedné -- vyber z obou posloupností první prvek, a pak opakovanì prvky porovnávej, zapisuj do setøídìné posloupnosti menší z nich a doplòuj dvojici z té polovièní posloupnosti, odkud pocházel zapsanı prvek.
\end{penumerate}
\end{e}

\begin{e}{Algoritmus}{0}{Quicksort}
Quicksort je jedním z nejrychlejších algoritmù pro tøídìní na vnitøní pamìti, pøestoe v nejhorším pøípadì mùe jeho èasová sloitost dosáhnout a $\Theta(n^2)$. Pro ideální i prùmìrná data dosahuje $\Theta(n\log n)$. Je také zaloen na principu \uv{rozdìl a panuj}, i kdy ponìkud jinım zpùsobem ne pøedchozí zmiòovanı, od nìho se liší i tím, e není stabilní.

Algoritmus nejdøív vybere nìjakı prvek, tzv. \emph{pivot}, a prvky s klíèem vìtší ne pivot pøesune do jiné èásti pole ne ty s klíèem menším. Pak rekurzivnì tøídí obì èásti pole -- kdy se dostane k polím délky 1, problém je vyøešen. Postup vypadá takto:
\begin{penumerate}
    \item Vyber pivot (jeden prvek ze seznamu). Tady jde o nejvìtší magii, protoe k dosaení nejlepší rychlosti by se mìl pokadé vybírat medián. Nejjednodušší je vybrat první, ale tento vıbìr ovlivòuje vıslednou rychlost práce, take se vyplatí napø vzít tøi prvky, porovnat je a vzít si z nich ten prostøední.
    \item Postupuj od zaèátku pole a hledej první prvek vìtší nebo rovnı ne pivot. A ho najdeš, postupuj od konce a najdi první prvek menší ne pivot. 
    \item Prvky prohoï a opakuj krok 2 a 3, dokud se hledání od zaèátku a od konce nepotká na nìjaké pozici -- tu pojmenujeme tøeba $k$.
    \item Rekurzivním voláním setøiï prvky $(0,\dots,k)$ a $(k+1,\dots,n-1)$ (má-li tøídìné pole délku $n$) -- to znamená pro obì èásti pole pokraèuj od kroku 1. Pokud je $k=0$ nebo $k=n-2$, není tøeba u rekurzivního volání, protoe posloupnosti délky 1 jsou setøídìné.
\end{penumerate}

Pro algoritmus existuje i nerekurzivní verze (staèí rekurzi nahradit zásobníkem úsekù èekajících na zpracování). Je vidìt, e na volbì pivotu závisí všechno -- pokud pokadé jako pivot volím 1. nebo $n-1$. hodnotu v poli v poøadí podle velikosti, dìlím pak vdy na èásti o délce 1 a $n-1$, take tento rekurzivní krok provedu a $n$-krát a dostanu se k èasu $\Theta(n^2)$. Samozøejmì, díky existenci algoritmu pro nalezení mediánu v èase $\Theta(n)$ je moné i tady dosáhnout zaruèené sloitosti $\Theta(n\log n)$, ale v praxi je to kvùli vysoké multiplikativní konstantì nepouitelné -- k vıbìru pivotu se vìtšinou s úspìchem uívá nìjaká jednoduchá heuristika, jak je nastínìno v popisu algoritmu samotného.

Heapsort bıvá pomalejší ne quicksort, ale zaruèuje nízkou èasovou sloitost i pro nejhorší pøípad a navíc potøebuje ménì pamìti -- nároky quicksortu navíc (kromì tøídìné posloupnosti) jsou $O(\log n)$ minimálnì, kvùli nutnosti pouití rekurzivního volání nebo zásobníku. Oproti mergesortu ho nelze pouít na data se sekvenèním pøístupem, tyto nevıhody ale vyvauje relativní jednoduchostí implementace a rychlostí v prùmìrném pøípadì.

Variantou quicksortu je \emph{introsort}, kterı ho kombinuje s heapsortem, pokud hloubka rekurze dosáhne nìjakıch nepøijatelnıch hodnot -- tak je zaruèena èasová sloitost $\Theta(n\log n)$ i v nejhorším pøípadì (samozøejmì je to ale v nejhorším pøípadì poøád pomalejší ne pouití jen heapsortu). Jedna z variant tohoto algoritmu se dá pouít k hledání $k$-tého nejmenšího prvku (tedy i mediánu), kdy dosahuje sloitosti $O(n)$ prùmìrnì a $O(n^2)$ nejhùøe.
\end{e}


\subsubsection*{Pøihrádkové tøídìní}

\begin{e}{Algoritmus}{0}{Bucket sort, Radix sort, pøihrádkové tøídìní}
Radix sort je zvláštní tøídící algoritmus -- jeho sloitost je toti lineární. Dosahuje to tím, e neporovnává všechny tøídìné prvky (sloitost problému tøídìní pomocí porovnávání je $\Theta(n\log n)$, take by to jinak nebylo moné), je ho ale moné pouít jen pro tøídìní dat podle klíèe z nìjaké ne pøíliš velké mnoiny -- max. rozsah tøídìnıch hodnot závisí na tom, jak velké pole si mùeme dovolit vymezit v pamìti pro tento úèel.

Nejjednodušší varianta (tzv. \emph{pigeonhole sort}, nebo-li \emph{counting sort}) opravdu poèítá s klíèi ze zadaného rozmezí $[l,h]$. Pro nìj si pøipraví cílové pole velikosti $h-l+1$, tj. \uv{pøihrádky}. Do nich pak pøímo podle klíèe pøehazuje ètené prvky (jestlie pøihrádky realizujeme jako seznamy, bude tøídìní dokonce stabilní). Nakonec projde pøihrádky od zaèátku do konce a co v nich najde, to vypíše (a vıstup bude setøídìnı). Variantou counting sortu je \emph{bucket sort}, kdy se do jedné pøihrádky nedávají jen prvky se stejnım klíèem, ale prvky s klíèem v nìjakém malém rozmezí -- ty pak lze setøídit rychle, protoe jich zøejmì nebude mnoho, a navíc se ušetøí pamì.


Protoe ale klíèe velikosti max. tisícù hodnot jsou vìtšinou trochu málo, v praxi se bìnì pouívají sloitìjší varianty -- ty zahrnují nìkolik prùchodù nahoøe popsaného algoritmu, pøi nich se tøídí jenom podle èásti klíèe. Ty se dìlí na ty, které zaèínají od nejménì vıznamné èásti klíèe (\emph{least significant digit radix sort}) a ty, které jdou od nejvıznamnìjší èásti (\emph{most significant digit}). První z nich mají tu vıhodu, e lze zachovat stabilitu tøídìní, druhá zase mùe tøídit i podle klíèù rùzné délky a zastavovat se po nalezení unikátních prefixù, take se hodí napø. pro lexikografické tøídìní podle øetìzcovıch klíèù.

Tøídìní typu least significant digit vypadá následovnì:
\begin{penumerate}
    \item Vezmi nejménì vıznamnou èást klíèe (urèitı poèet bitù).
    \item Rozdìl podle této èásti klíèe data do pøihrádek, ale v nich zachovej jejich poøadí (to je nutné kvùli následnému prùchodu, zároveò to dìlá z tohoto algoritmu stabilní tøídìní).
    \item Opakuj toto pro další (vıznamnìjší) èást klíèe.
\end{penumerate}

Most significant digit varianta (rekurzivní verze, je zaloená na bucket sortu) bìhá takto:
\begin{penumerate}
    \item Vezmi nejvıznamnìjší èást klíèe (první písmeno, napøíklad).
    \item Rozdìl prvky podle této èásti do pøihrádek (take v jedné se jich octne docela hodnì)
    \item Rekurzivnì setøiï kadou z pøihrádek (zaèni podle další èásti klíèe), pokud je v ní více ne jeden prvek (tohle zaruèí zastavení za rozlišujícím prefixem).
    \item Slep pøihrádky do jedné (setøídìné) posloupnosti.
\end{penumerate}

Popisované algoritmy vìtšinou potøebují $O(n+(h-l))$ èasu k tøídìní, je-li $h-l$ (zhruba) poèet pøihrádek -- to znamená, e sice jde o sloitost lineární, ale lineární i v poètu pøihrádek, co se nemusí vdy oproti konvenènímu tøídìní vyplatit. Navíc jsou problémem vysoké nároky na pamì (nelze tøídìní provést \uv{na místì} v jediném poli). Pro malou mnoinu hodnot klíèù (nebo u most significant digit varianty krátké odlišující prefixy) jsou ale èasovì efektivnìjší.
\end{e}



\subsubsection*{Tøídící sítì}

Zdrojem této sekce jsou zápisky z pøednášek Prof. L. Kuèery Algoritmy a datové struktury II.
\bigskip

\begin{e}{Definice}{0}{Bitonická posloupnost}
Øekneme, e posloupnost prvkù je \emph{bitonická}, pokud po spojení do cyklu (tedy nultı prvek za $n$-tı) obsahuje dva monotónní úseky. Nebo-li obsahuje a na fázovı posuv dva monotónní úseky.
\end{e}

\begin{e}{Definice}{0}{Komparátor}
\emph{Komparátor} je speciální typ hradla (pøedstavme si pod tím nedìlitelnou elektronickou souèástku, pøípadnì jen virtuální), která má dva vıstupy a dva vstupy. Pokud na vstupy pøivedeme dva prvky (klíèe, èísla), z levého vıstupu vydá menší z nich a z pravého vıstupu vìtší (take vlastnì porovná dva prvky a na vıstup je vyplivne ve správném poøadí). Pracuje v konstantním èase.
\end{e}

\begin{e}{Definice}{0}{Tøídící sí}
Tøídící sí je správnì sestavená mnoina komparátorù dohromady spojená vstupy a vıstupy tak, e pøi pøivedení posloupnosti délky $n$ na vstup ji vydá setøídìnou na vıstupu. Komparátory v ní jsou rozèlenìné do hladin, jejich poèet pak udává celkovou dobu vıpoètu -- pøedpokládá se tam, e komparátory v jednotlivıch vrstvách pracují paralelnì, take tøídící sítì mohou dosahovat èasové sloitosti pouhıch $O(\log n)$. Algoritmus s takovou èasovou sloitostí sice existuje, ale má velmi vysokou multiplikativní konstantu, take se v praxi nepouívá. Pøíkladem tøídící sítì je i bitonické tøídìní.
\end{e}

\begin{e}{Algoritmus}{0}{Bitonické tøídìní}
Bitonická tøídící sí je zaloena na pouití bitonickıch posloupností a rekurze. Obvod (pro tøídìní dat délky $n$) se dìlí na dvì èásti:
\begin{pitemize}
    \item První èást setøídí (rekurzivnì) $1/2$ vstupu vzestupnì, druhou polovinu sestupnì a tím vytvoøí bitonickou posloupnost. Obsahuje tedy dvì tøídící sítì pro tøídìní posloupností délky $\frac{n}{2}$.
    \item Druhá èást tøídí jen bitonické posloupnosti -- první její vrstva rozdìlí bitonickou posloupnost na vstupu na dvì bitonické posloupnosti (z vìtších a menších èísel). Další vrstvy u jsou opìt implementovány rekurzivnì -- tedy druhá vrstva dostane dvì posloupnosti a vyrobí z nich ètyøi atd., a nakonec dojde k \uv{bitonickım posloupnostem} délky 1.
\end{pitemize}

K rozdìlení jedné bitonické posloupnosti délky $k$ na dvì staèí jen $\frac{k}{2}$ komparátorù, které porovnávají vdy $i$-tı a $k+i$-tı prvek. Dojde sice k nìjakému fázovému posuvu, ale to nièemu nevadí. Dobøe je to vidìt pøi znázornìní na krunici, doporuèuji prohlédnout si postup v programu Algovision Prof. Kuèery (\texttt{http://kam.mff.cuni.cz/\~{}ludek/AlgovisionPage.html}).

Je vidìt, e poèet vrstev potøebnıch k dìlení bitonickıch posloupností délky $N$ je $log_2 N$ ($B(N)=\log N$). Pro celkovı poèet vrstev, a tedy dobu zpracování -- $T(n)$ nám vychází následující vzorec
$$T(N) = T(\frac{n}{2}) + B(N) = \log N + \log(N/2) + \dots + 1$$
z èeho díky vzorci pro souèet aritmetické posloupnosti $1+2+\dots+k=\frac{k(k+1)}{2}$ vyjde
$$T(N) = O(\frac{1}{2} \log^2 N)$$
\end{e}
