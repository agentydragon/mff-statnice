\subsection{Pravdìpodobostní algoritmy -- testování prvoèíselnosti\footnote{tato otázka nebyla asi nikdy zkoušena, a tak je to jenom takovy nástøel Zdroj: vıborné Èepkovy slajdy na ADS2 - zda se ze je ocenuju az ted :)}}

Pravdìpodobnostní (náhodnostní) algoritmy jsou nedeterministické algoritmy, které se snaí najít øešení rychleji nebo øešení tìko øešitelnıch problémù, èasto NP-úplnıch problémù. Pravdìpodobnostní algoritmus se mùe náhodnì rozhodovat mezi rùznımi monostmi jak pokraèovat. Pro stejnı vstup mùe dávat takovı algoritmus rùzné vısledky, které mohou bıt dokonce nesprávné. Mnohdy se tedy na daném vstupu spustí pravdìpodobnostní algoritmus vícekrát, aby se s vìtší pravdìpodobností dospìlo ke správnému vısledku.
\\\\
Pravdìpodobnostních algoritmù je mnoho typù, zde zmíníme jen dva a to algoritmy typu Las Vegas a typu Monte Carlo. 

\subsubsection*{Algoritmy typu Las Vegas} 
Vısledek je vdy správnı, náhodnost ovlivòuje pouze dobu bìhu algoritmu, tj. po jaké cestì se algoritmus ke správnému vısledku dobere.
\\\\ 
\begin{prikladN}{randomizovanı QuickSort} Od deterministické verze se liší náhodnımi vıbìry pivota pøi kadém dìlení posloupnosti, co poskytuje následující vıhody
\begin{pitemize}
\item dává dobrı prùmìrnı èas (tj. $O(n \log n)$) i v pøípadì, e data na vstupu nejsou náhodné permutace – ádnı vstup není apriori špatnı (pro kadı deterministickı vıbìr pivota existují apriori špatné vstupy)
\item mùe bıt spuštìn paralelnì v nìkolika kopiích, vısledek je získán z kopie, kde vıpoèet skonèí nejdøíve (pro deterministickou verzi nemá takovı postup ádnı smysl)
\end{pitemize}
\end{prikladN}
\subsubsection*{Algoritmy typu Monte Carlo} 
Náhodnost ovlivòuje jak dobu bìhu, tak správnost vısledku: algoritmus mùe udìlat chybu, ale pouze jednostrannì (u odpovìdí ANO/NE) a s omezenou pravdìpodobností. 
\\\\
\begin{prikladN}{Rabin-Millerùv algoritmus na testování prvoèíselnosti} 
Pro zadané pøirozené èíslo n (rychle) rozhodnout zda je n prvoèíslo 
\\\\
\begin{vetaN}{Malá Fermatova} Nech p je prvoèíslo. Potom $\forall k \in\{1,2, … ,p-1\}$ platí $k^{p-1} \equiv 1(\mod p)$
\end{vetaN} 
\\\noindent
Pokud $n$ není prvoèíslo, tak zkusíme (náhodnì) najít „svìdka“ $k$, porušujícího $k^{n-1} \equiv 1(\mod n)$, kterı „dosvìdèuje“, e $n$ je opravdu èíslo sloené (není to prvoèíslo). Problém - pro nìkterá sloená èísla je svìdkù pøíliš málo, take je pøíliš malá pravdìpodobnost, e nìjakého svìdka (náhodnì) vybereme. 
\\\\
\begin{definice} Nech T je mnoina dvojic pøirozenıch èísel, kde $(k,n) \in T$ pokud $0 < k < n$ a je splnìna alespoò jedna z následujících dvou podmínek:\\
1. neplatí $k^{n-1} \equiv 1(\mod n)$,\\
2. existuje $i$ takové, e $m = (n-1) / 2^i$ je pøirozené èíslo a platí $1 < NSD(k^{m-1}-1, n) < n$ 
\end{definice}
\begin{vetaN}{1} Èíslo $n$ je sloené tehdy a jen tehdy, kdy existuje $k$ takové, e $(k,n)\in T$.
\end{vetaN}
\begin{vetaN}{2} Nech $n$ je sloené èíslo. Pak existuje alespoò $(n-1)/2$ takovıch èísel $k$, pro které platí $(k,n)\in T$.
\end{vetaN}
\begin{obecne}{Algoritmus:}
\begin{verbatim}
        Rabin-Miller(n); 
                for i:=1 to poèet do 
                        ki := náhodné pøirozené èíslo z intervalu [1,n-1];
                        if (ki,n) in T then Return(n je sloené);                
                Return(n je prvoèíslo)
\end{verbatim}
\end{obecne}
\noindent
Pokud $Rabin-Miller(n)$ rozhodne, e $n$ je sloené, tak je to zaruèenì správnı vısledek (byl nalezen „svìdek“), pokud $Rabin-Miller(n)$ rozhodne, e $n$ je prvoèíslo, tak se mùe jednat o chybu, ale pouze v pøípadì, e všechna vybraná $k_i$ byli „ne-svìdci“ pro sloené èíslo $n$, co ale mùe (díky Vìtì 2) nastat nejvıše s pravdìpodobností $$P(chyba) \leq (1/2)^{pocet}$$ pokud jsou vıbìry jednotlivıch $k_i$ vzájemnì nezávislé 
\\\\
\begin{obecne}{Vlastnosti algoritmu:}
• zvyšováním poètu iterací (poètu testovanıch $k_i$) lze dostat libovolnì malou (pøedem zvolenou) pravdìpodobnost chyby
\\
• jednotlivé iterace (testy pro rùzná $k_i$) lze provádìt paralelnì 
\end{obecne}
\begin{obecne}{Èasová sloitost:} kadá iterace trvá jen polynomiálnì vzhledem k délce zápisu èísla $n$ (tj. k délce vstupu), k tomu je ovšem potøeba ukázat, e test zda $(k_i,n) \in T$ je mono provést v èase polynomiálním v $\log n$, co není triviální (je nutné mít další znalosti z teorie èísel)
\end{obecne}
\end{prikladN}

