\subsection{Algoritmy vyhledávání v textu}
Toto sú len ve¾mi struèné vıahy z wikipedie. Aktuálne sú tu len preto, aby si èlovek rıchlo vybavil, o èom tie algoritmy sú :-)

\subsubsection*{Rabin-Karp}
Umoòuje vyh¾adávanie viacerıch reazcov v texte naraz - uitoèné napr. na h¾adanie plagiátov. Základnou myšlienkou je vyh¾adávanie v texte pomocou hashov (rolling hashes - idea je \texttt{s[i+1..i+m] = s[i..i+m-1] - s[i] + s[i+m]})...

Algoritmus pre vyh¾adávanie jedného reazca:
\begin{verbatim}
 1 function RabinKarp(string s[1..n], string sub[1..m])
 2     hsub := hash(sub[1..m])
 3     hs := hash(s[1..m])
 4     for i from 1 to n-m+1
 5         if hs = hsub
 6             if s[i..i+m-1] = sub
 7                 return i
 8         hs := hash(s[i+1..i+m])
 9     return not found
\end{verbatim}

Najhoršia zloitos je $\Omega(mn)$. Pri vyh¾adávaní viacerıch reazcov len spoèítame hashe všekıch h¾adanıch stringov a pri nájdení niektorého z hashov príslušnı reazec porovnáme s textom... Ostatné algoritmy spotrebujú èas $O(n)$ na nájdenie 1 reazca a teda $O(nk)$ na vyh¾adanie $k$ reazcov. Naproti tomu tento algoritmus má oèakávanú zloitos $O(n+k)$ - pretoe vyh¾adávanie v hashovacej tabu¾ke, èi je hash podreazca textu rovnı hashu niektorého z h¾adaného reazcov, trvá $O(1)$.

\subsubsection*{Aho-Corasick}

Dokáe vyh¾adáva viacero reazcov naraz - pouíva na to trie-like štruktúru (koneènı automat), ktorı obsahuje nasledujúce \uv{prvky}:
\begin{penumerate}
	\item koneèná mnoina $Q$ - stavy
	\item koneèná abeceda $A$
	\item transition funkcia $g$: $Q \times A \rightarrow Q + \{fail\}$
	\item failure funkcia $h$: $Q \rightarrow Q + \{fail\}$. $h(q)=q'$ práve vtedy keï spomedzi všetkıch stavov Q dáva $q'$ najdlhší suffix z $path(q)$.
	\item koneèná mnoina $F$ - koncové stavy
\end{penumerate}

Príklad \uv{hotového} automatu pre slová P=\{ab, ba, babb, bb\}:

\par\begin{center}\includegraphics[width=8cm]{informatika/algoritmy_a_ds/obrazky/ahocorasick-automatron.png}\end{center}

Zloitos vyh¾adávania je lineárna vzh¾adom k dåke textu a poètu nájdenıch \uv{slov} (pozn.: ten môe by a kvadradickı - slovník a, aa, aaa, aaaa; reazec aaaa). Trie štruktúru je moné vyrobi raz a potom pouíva poèas vyh¾adávania - uchovávame si najdlší match a pouívame suffix odkazy (aby sme udrali linearitu vıpoètu).

Vıstavba stromu se provede prostım zaøazováním slov do trie-stromu podle prefixù. Na této struktuøe je potom moné v lineárním èase (vzhledem k poètu znakù hledanıch slov) pøedpoèítat hodnoty failure funkce: automat vdy pustíme na sufix aktuálnì zkoušeného slova, bez prvního znaku. Díky tomu, e prùbìnì ukládáme hodnoty nalezenıch slov, pro kadé písmeno provede max. 2 kroky (postup vpøed a uloení hodnoty, kam bych spadnul).


\subsubsection*{Knuth-Morris-Pratt}

Obdoba Aho-Corasick, ale h¾adá len jedno slovo. Samozrejme nie je potrebná dopredná funkcia (vdy iba nasledujúci znak), pouíva sa \uv{partial match} tabu¾ka (failure funkcia).

\begin{verbatim}
algorithm kmp_search:
    input:
        S (the text to be searched)
        W (the word sought)

    m = 0 (the beginning of the current match in S)
    i = 0 (the position of the current character in W)
    an array of integers, T (the table, computed elsewhere)

    while m + i is less than the length of S, do:
        if W[i] = S[m + i],
            i = i + 1
            if i equals the length of W,
                return m
        otherwise,
            m = m + i - T[i],
            if i is greater than 0,
                i = T[i]

    (if we reach here, we have searched all of S unsuccessfully)
    return the length of S
\end{verbatim}

Zloitos algoritmu je je $O(k)$ (k je dåka S) - cyklus je vykonanı najviac $2k$ krát.

Algoritmus na vırobu tabu¾ky:
\begin{verbatim}
algorithm kmp_table:
    input:
        W (the word to be analyzed)
        T (the table to be filled)

    i = 2 (the current position we are computing in T)
    j = 0 (the zero-based index in W of the next
           character of the current candidate substring)

    (the first few values are fixed but different
          from what the algorithm might suggest)
    let T[0] = -1
    T[1] = 0

    while i is less than the length of W, do:
        (first case: the substring continues)
        if W[i - 1] = W[j],
            T[i] = j + 1
            i = i + 1
            j = j + 1

        (second case: it doesn't, but we can fall back)
        otherwise, if j > 0,
            j = T[j]

        (third case: we have run out of candidates. Note j = 0)
        otherwise,
            T[i] = 0
            i = i + 1
\end{verbatim}


Zloitos tohoto algoritmu je $O(n)$ (n je dåka W) - cyklus skonèí najviac po $2n$ iteráciách.
