\subsection{Algoritmy vyhledávání v textu}
Toto sú len ve¾mi struèné výahy z wikipedie. Aktuálne sú tu len preto, aby si èlovek rýchlo vybavil, o èom tie algoritmy sú :-)

\subsubsection*{Rabin-Karp}
Umožòuje vyh¾adávanie viacerých reazcov v texte naraz - užitoèné napr. na h¾adanie plagiátov. Základnou myšlienkou je vyh¾adávanie v texte pomocou hashov (rolling hashes - idea je \texttt{s[i+1..i+m] = s[i..i+m-1] - s[i] + s[i+m]})...

Algoritmus pre vyh¾adávanie jedného reazca:
\begin{verbatim}
 1 function RabinKarp(string s[1..n], string sub[1..m])
 2     hsub := hash(sub[1..m])
 3     hs := hash(s[1..m])
 4     for i from 1 to n-m+1
 5         if hs = hsub
 6             if s[i..i+m-1] = sub
 7                 return i
 8         hs := hash(s[i+1..i+m])
 9     return not found
\end{verbatim}

Najhoršia zložitos je $\Omega(mn)$. Pri vyh¾adávaní viacerých reazcov len spoèítame hashe všekých h¾adaných stringov a pri nájdení niektorého z hashov príslušný reazec porovnáme s textom... Ostatné algoritmy spotrebujú èas $O(n)$ na nájdenie 1 reazca a teda $O(nk)$ na vyh¾adanie $k$ reazcov. Naproti tomu tento algoritmus má oèakávanú zložitos $O(n+k)$ - pretože vyh¾adávanie v hashovacej tabu¾ke, èi je hash podreazca textu rovný hashu niektorého z h¾adaného reazcov, trvá $O(1)$.

\subsubsection*{Aho-Corasick}

Dokáže vyh¾adáva viacero reazcov naraz - používa na to trie-like štruktúru (koneèný automat), ktorý obsahuje nasledujúce \uv{prvky}:
\begin{penumerate}
        \item koneèná množina $Q$ - stavy
        \item koneèná abeceda $A$
        \item transition funkcia $g$: $Q \times A \rightarrow Q + \{fail\}$
        \item failure funkcia $h$: $Q \rightarrow Q + \{fail\}$. $h(q)=q'$ práve vtedy keï spomedzi všetkých stavov Q dáva $q'$ najdlhší suffix z $path(q)$.
        \item koneèná množina $F$ - koncové stavy
\end{penumerate}

Príklad \uv{hotového} automatu pre slová P=\{ab, ba, babb, bb\}:

\par\begin{center}\includegraphics[width=8cm]{informatika/algoritmy_a_ds/obrazky/ahocorasick-automatron.png}\end{center}

Zložitos vyh¾adávania je lineárna vzh¾adom k dåžke textu a poètu nájdených \uv{slov} (pozn.: ten môže by až kvadradický - slovník a, aa, aaa, aaaa; reazec aaaa). Trie štruktúru je možné vyrobi raz a potom používa poèas vyh¾adávania - uchovávame si najdlší match a používame suffix odkazy (aby sme udržali linearitu výpoètu).

Výstavba stromu se provede prostým zaøazováním slov do trie-stromu podle prefixù. Na této struktuøe je potom možné v lineárním èase (vzhledem k poètu znakù hledaných slov) pøedpoèítat hodnoty failure funkce: automat vždy pustíme na sufix aktuálnì zkoušeného slova, bez prvního znaku. Díky tomu, že prùbìžnì ukládáme hodnoty nalezených slov, pro každé písmeno provede max. 2 kroky (postup vpøed a uložení hodnoty, kam bych spadnul).


\subsubsection*{Knuth-Morris-Pratt}

Obdoba Aho-Corasick, ale h¾adá len jedno slovo. Samozrejme nie je potrebná dopredná funkcia (vždy iba nasledujúci znak), používa sa \uv{partial match} tabu¾ka (failure funkcia).

\begin{verbatim}
algorithm kmp_search:
    input:
        S (the text to be searched)
        W (the word sought)

    m = 0 (the beginning of the current match in S)
    i = 0 (the position of the current character in W)
    an array of integers, T (the table, computed elsewhere)

    while m + i is less than the length of S, do:
        if W[i] = S[m + i],
            i = i + 1
            if i equals the length of W,
                return m
        otherwise,
            m = m + i - T[i],
            if i is greater than 0,
                i = T[i]

    (if we reach here, we have searched all of S unsuccessfully)
    return the length of S
\end{verbatim}

Zložitos algoritmu je je $O(k)$ (k je dåžka S) - cyklus je vykonaný najviac $2k$ krát.

Algoritmus na výrobu tabu¾ky:
\begin{verbatim}
algorithm kmp_table:
    input:
        W (the word to be analyzed)
        T (the table to be filled)

    i = 2 (the current position we are computing in T)
    j = 0 (the zero-based index in W of the next
           character of the current candidate substring)

    (the first few values are fixed but different
          from what the algorithm might suggest)
    let T[0] = -1
    T[1] = 0

    while i is less than the length of W, do:
        (first case: the substring continues)
        if W[i - 1] = W[j],
            T[i] = j + 1
            i = i + 1
            j = j + 1

        (second case: it doesn't, but we can fall back)
        otherwise, if j > 0,
            j = T[j]

        (third case: we have run out of candidates. Note j = 0)
        otherwise,
            T[i] = 0
            i = i + 1
\end{verbatim}


Zložitos tohoto algoritmu je $O(n)$ (n je dåžka W) - cyklus skonèí najviac po $2n$ iteráciách.
\\\\
\begin{e}{Report}{0}{Bednárek} Algoritmy vyhledávání v textu U tìch algoritmù se mì ještì dodateènì zeptal jak bych øešil vyhledávání regulárního výrazu, naštestí už pøedtím se ptal na determinismus automatu u aho-corrasica tak bylo lehké si odvodit, že to bude nedeterministický automat, ještì se ptal jak bude dlouhý u regulárního výrazu délky p, tak to jsem odvodil, že staèí p stavù, ještì ho zajímalo jeho determinizace $->$ stavy jsou množiny stavù pùvodního automatu, stavù max 2 na p-tou.
I celkovì úplnì v pohodì. 
\end{e}
