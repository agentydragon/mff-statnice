\subsection{Procesy, vlákna, plánování}

\subsubsection*{Procesy a vlákna}
Systémové volání je interface mezi OS (kernelspace) a uívatelskımi programy (userspace).

\begin{e}{Definice}{0}{Proces}
  \emph{Proces} je inštancia vykonávaného programu. Proces má vlastní
\textbf{pid (Process ID), práva (uivatele), adresní prostor (pamì), vlákna a otevøené soubory}.
\end{e}

\obrazekvpravo{informatika/operacne_systemy_a_hw/obrazky/procesy_stavy.png}{Pøechody mezi stavy procesu}{}{0.45}
\begin{e}{Stavy procesu}{0}{0}
Poèas ivota sa môe proces/vlákno nachádza v rôznych stavoch:
\begin{pitemize}
  \item \emph{beící}~-- jeden proces/vlákno na procesor,
  \item \emph{zablokovanı}~-- pri pouití blokujúceho volania~-- I/O disku atï.,
  \item \emph{pøipravenı}~-- skonèilo blokovanie; spotreboval všetok pridelenı èas resp. vrátil riadenie systému, èaká na nové pridelenie procesora,
  \item \emph{zombie}~-- po ukonèení procesu, keï u nepracuje~-- ale ešte nebol vymazanı\footnote{taky stav zombie tam neni jenom kvuli vtipnosti; kdyz proces skonci
svoji cinnost, tak se treba muze cekat na to, az si navratovou hodnotu
procesu nekdo vyzvedne - a potom se proces muze oznacovat ve stavu
zombie }.
\end{pitemize}
\end{e}

\begin{e}{Organizace pamìti procesu}{0}{0}

Pamì procesu (spuštìného programu) lze rozdìlit do nìkolika èástí:
\begin{pitemize}
\item \emph{kód programu (text segment)} \\
vytvoøen pøi pøekladu, souèást spustitelného souboru, nemìnnı a má pevnou délku; obvykle bıvá chránìn proti zápisu
\item \emph{statická data (data segment)} -- data programu, jejich velikost je známa ji pøi pøekladu a jejich pozice se bìhem programu nemìní (je pøipraven kompilátorem a jeho formát je takté zadrátovanı ve spustitelném souboru, u inicializovanıch statickıch dat je tam celı uloenı); v jazyce C jde o globální promìnné a lokální data deklarovaná jako \texttt{static} (promìnné alokované pouze jednou), konstanty
\item \emph{halda (heap segment)} -- vytváøen startovacím modulem (C Runtime library), ukládají se sem dynamicky vznikající objekty (\texttt{malloc, new})  neinicializovaná data, i seznam volného místa. \\Halda zjemnuje to, co ti dovoluje spravce virtualni pameti. Ten ti dovoluje taky alokovat pamet a jinak s ni pracovat, ale protoze umi pracovat jen s celymi strankami (treba 4 KB velke), tak proste nekolikabajtove bloky od nej dostat primo nemuzes. A halda prave ty cele alokovane stranky rozdeluje do mensich bloku (postupne z nich ukrajuje, jak volas \texttt{malloc()})... pokud ji volna pamet dojde, alokuje si dalsi stranky... a tak dale.
\item \emph{volná pamì} \\
postupnì jí zaplòuje z jedné strany zásobník a z druhé halda
\item \emph{zásobník (stack segment)} \\
informace o volání procedur (\uv{aktivaèní záznamy}) --- návratové adresy, parametry a návratové hodnoty (nejsou-li pøedávány v registrech), nìkteré jazyky (Pascal, C) pouívají i pro úschovu lokálních promìnnıch. Typicky roste zásobník proti haldì (od \uv{konce} pamìti k niším adresám).
\end{pitemize}
\end{e}

\begin{e}{Definice}{0}{Vlákno (Thread)}
  \emph{Vlákno} je monos pre program ako sa \uv{rozdeli} na dva alebo viac
  zároveò (resp. pseudo-zároveò) vykonávanıch úloh. Oproti procesu mu nie je
  pridelená vlastná pamä~-- je to len miesto vykonávania inštrukcií v programe.
  Oproti procesu sú jeho \uv{atribútmi} len: \textbf{stav(+priorita), zásobník, registrov CPU (i hodnotou PC\footnote{kdy se vlákno pøeruší tak se uloí
i to kam v nìm PC ukazoval - aby pak mohlo pokraèovat kde zkonèilo})}.
\end{e}
\begin{figure}[h]
  \centering
  \subfloat[Process control block]{\label{fig:pcb_process} \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/pcb_process_control_block.png}} \hfill
  \subfloat[Process control block s vlákny]{\label{fig:pcb_thread}\includegraphics[width=8.5cm]{informatika/operacne_systemy_a_hw/obrazky/pcb_process_control_block_vlakna.png}}
  \caption{Process Control Block - execution context \footnotesize(všimnìte si
  oddìleného kernel a user módu)}
  \label{fig:pcb}
\end{figure}

\newpage
\textbf{Implementace:}
\begin{pitemize}
        \item \textbf{User Level Threads}(1.diagram) - thread management dìlá aplikace (nemusí bıt podporovány OS), kadı proces ma thread table, kdy systém zablokuje proces zablokují se i všechny jeho thready
        \item \textbf{Kernel Threads}(2.diagram) - thread management dìlá OS (musí podporovat), thread table je globální, systém blokuje pouze jednotlivé thready
  \begin{center}
  \begin{center}
    \includegraphics[height=6cm]{informatika/operacne_systemy_a_hw/obrazky/user-threads.png}
    \includegraphics[height=6cm]{informatika/operacne_systemy_a_hw/obrazky/kernel-threads.png}
  \end{center}  
  \end{center}
\end{pitemize}
\emph{Multithreading} - schopnost systému efektivnì pouívat více threadù, modely:
\begin{pitemize}
        \item \textbf{many-to-one (User Level Threads)} - mnoho user-level threadù je namapováno na jednu kernel entitu, pouívá se na systémech nepodporujících kernel thready (napø. Linux - GNU Portable Threads)
        \item \textbf{one-to-one (Kernel Threads)} - kadı user-level thread je namapován na jeden kernel thread (napø. win2000, Linux - NGPT)
\end{pitemize}

\subsubsection*{Plánování}

Pøi plánování procesoru se v operaèním systému \textit{plánovaè} (anglicky scheduler) rozhoduje, kterému procesu bude pøidìlen procesor, a tedy kterı proces v následujícím èasovém úseku bude procesor poèítaèe vyuívat pro svùj bìh. K plánování procesoru dochází v následujících situacích:
\begin{pitemize}
        \item pokud nìkterı bìící proces pøejde do stavu blokovanı
        \item pokud nìkterı proces skonèí
        \item pokud je bìící proces pøeveden do stavu pøipravenı
        \item pokud je nìkterı proces pøeveden ze stavu blokovanı do stavu pøipravenı
\end{pitemize}
 Plánovanie pritom môe by \textit{preemptívní} (vìtšinou pomocí pøerušení, bez spolupráce s programem, plnì v reii OS - Windows NT, Linux) alebo \textit{nepreemptivní} (vyaduje spolupráci s programem, kooperatívne~-- Windows 3.x).
\\\\
\begin{obecne}{Metriky OS pro plánování procesù:}
\begin{pitemize}
 \item doba odezvy (response time, turnaround) -- do ukonèeni procesu, do prvni odezvy
 \item propustnost (throughput) -- poèet dokonèenych uloh za jednotku èasu
 \item vyuiti procesoru (utilization)
 \item spravedlnost (fairness)
\end{pitemize}
\end{obecne}

\begin{obecne}{Algoritmy:}
\begin{pitemize}
        \item \textbf{First Come First Served (FCFS)}: nepreemptívny, procesy plánovány v poøadí, v jakém pøicházejí, procesy bìí dokud neskonèí
  \begin{center}
    \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/fcfs.png}
  \end{center}
        \item \textbf{Round Robin}: preemptívne rozšírenie FCFS, kadı proces má stejné povolené èasové kvantum na bìh, po jeho uplynutí je proces pøesunut na konec fronty
  \begin{center}
    \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/round-robin.png}
  \end{center}
        \item \textbf{Plánovaní s nìkolika frontami}: kadé frontì je pøiøazena
nìjaká priorita, bereme procesy s fronty s nejvyšší prioritou. Pokud vyèerpá
svoje èasové quantum tak jí zaøadíme do fronty o úroveò ní.
  \begin{center}
    \includegraphics[width=8cm]{informatika/operacne_systemy_a_hw/obrazky/vice-front.png}
  \end{center}

        \item \textbf{Symmetric multiprocessing (SMP)}: druh víceprocesorovıch systémù, u kterıch jsou všechny procesory v poèítaèi rovnocenné,  fronta CPU èakajúcich na pripravené procesy (aktívne (spotrebováva energiu) vs. pasívne èakanie (špeciálne inštrukcie)), \uv{vzah}/afinita procesov k CPU
        \end{pitemize}
\end{obecne}

\begin{reportN}{Zavoral}
zhruba to co je vo vypiskach, diskusia dalej pokracovala o rozdieloch medzi vlaknami a procesmi - napr ako su implementovane vlakna v OS ktory ich nepodporuje (snazil som sa to nejak ukazat na JVM, ale podrobnosti som velmi nevedel, takze to bolo dost napovedy pana Zavorala a par slov odo mna :? ).
\\\\
nìkdo jiny: som letel na Vlaknach (nevedel som ze su reprezentovane hodnotou registrov, prog. citaca a zasobnikom)
\end{reportN}
