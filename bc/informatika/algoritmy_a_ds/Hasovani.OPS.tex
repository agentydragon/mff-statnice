\newcommand{\nadpis}[1]{\pagebreak[2]\ramcek{\subsubsection*{#1}}}

\subsection{Hašování}

\begin{e}{Definice}{0}{slovníkový problém} Dáno univerzum $U$, máme reprezentovat
$S \subseteq U$ a navrhnout algoritmy pro operace
\begin{pitemize}
\item MEMBER(x) - zjistí zda $x \in S$ a pokud ano nalezne kde,
\item INSERT(x) - pokud $x \notin S$, vloží $x$ do struktury reprezentující $S$,
\item DELETE(x) - když $x \in S$, smaže $x$ ze struktury reprezentující $S$.
\end{pitemize}
\end{e}

Napøíklad pomocí pole mùžeme tyto operace implementovat rychle, ale nevýhodou
je prostorová nároènost. Pro velké množiny je to nìkdy dokonce nemožné.
\emph{Hašování} se snaží zachovat rychlost operací a odstranit prostorovou
nároènost.

Podívejme se nyní na \emph{základní ideu} hašování. Mìjme univerzum $U$ a
množinu $S \subseteq U$ takovou, že $|S| << |U|$. Dále mìjme funkci
$h:U\rightarrow\{0,1,\dots,m-1\}$. Množinu $S$ potom reprezentujeme tabulkou
(polem) o velikosti $m$ tak, že prvek $x \in S$ je uložen na øádku $h(x)$.

\begin{e}{Definice}{0}{Hašovací funkce, kolize} Funkci
$h:U\rightarrow\{0,1,\dots,m-1\}$ potom nazýváme \textbf{hašovací funkcí}.
Situaci $h(s)=h(t)$, pro $s \neq t; s,t \in S$  nazveme \textbf{kolize}.
\end{e}

Jelikož mohutnost univerza $U$ je vìtší než velikost hašovací tabulky, nelze se
kolizím úplnì vyhnout. Existuje spousta rùzných metod, jak kolize øešit.
Podívejme se tedy na nìkteré podrobnìji.

\begin{e}{Definice}{0}{0}
Ještì si zavedeme nìkteré znaèení. Velikost $S$ (hašované množiny) oznaème
\textbf{n}, velikost tabulky (pole) oznaème \textbf{m}, a faktor naplnìní
\textbf{$\alpha=\frac{n}{m}$}.
\end{e}

\subsubsection*{Hašování se separovanými øetìzci}

Použijeme pole velikosti $m$, jehož $i$-tá položka bude spojový seznam $S_i$
takový, že $s\in S_i \Leftrightarrow h(s)=i$, pro $s\in S$. Èili každý øádek
pole obsahuje spojový seznam všech (kolidujících) prvkù, které jsou hašovány na
tento øádek. Seznamy nemusí být uspoøádané, vznikají tak, jak jsou vkládány
jednotlivé prvky do struktury.

\begin{e}{Algoritmus}{0}{Hašování se separovanými øetìzci}
\begin{pitemize}
\item \textbf{MEMBER} -- Spoèteme hodnotu hašovací funkce $h(x)$, prohledáme
øetìzec zaèínající na pozici $h(x)$ a zjistíme zda se prvek nachází, èi
nenachází ve struktuøe. Pokud se prvek v databázi nachází, tak musí nutnì ležet
v tomto øetìzci.
\item \textbf{INSERT} -- Zjistíme zda $x$ je v øetìzci $h(x)$, pokud ne, pøidáme
ho nakonec, v opaèném pøípadì nedìláme nic.
\item \textbf{DELETE} -- Vyhledá $x$ v øetìzci $h(x)$ a smaže ho. Pokud se tam
$x$ nenachází, neudìlá nic.
\end{pitemize}
\end{e}

\paragraph{Oèekávaný poèet testù} v neúspìšném pøípadì je pøibližnì
$e^{-\alpha} + \alpha$ a pøi úspìšném vyhledávání pøibližnì
$1+\frac{\alpha}{2}$.

\subsubsection*{Hašování s uspoøádanými øetìzci}

Jak již je zøejmé z názvu je tato metoda témìø stejná jako pøedchozí. Jediný
rozdíl je, že jednotlivé seznamy jsou uspoøádány vzestupnì dle velikosti
prvkù.

\begin{e}{Algoritmus}{0}{Hašování s uspoøádanými øetìzci}
Rozdíly jsou pouze pro operaci \textbf{MEMBER}, kde skonèíme prohledávání, když
dojdeme na konec, nebo když nalezneme prvek, který je vìtší než hledaný a
operaci \textbf{INSERT}, které vkládá prvek na místo kde jsme ukonèili
vyhledávání (pøed prvek, který ho ukonèil).
\end{e}

\paragraph{Oèekávaný poèet testù} v neúspìšném pøípadì je pøibližnì roven
$e^{-\alpha}+1+\frac{\alpha}{2}-\frac{1}{\alpha}(1-e^{-\alpha})$ a v úspìšném
pøípadì je pøibližnì $1+\frac{\alpha}{2}$.

Nevýhodou pøedchozích dvou metod je nerovnomìrné využití pamìti. Zatímco
nìkteré seznamy mohou být dlouhé, v nìkterých není prvek žádný. Øešením je najít
zpùsob, jak kolidující prvky ukládat na jiné (prázdné) øádky tabulky. Potom je
ale nutné každý prvek tabulky rozšíøit a položky pro práci s tabulkou. 

Èím použijeme sofistikovanìjší metodu ukládání dat do tabulky, tím více budeme
potøebovat položek pro práci s tabulkou a tedy vzroste pamìová nároènost. Naším
cílem je tedy najít rozumný kompromis mezi sofistikovaností (rychlostí)
strategie a její pamìovou nároèností. Podívejme se na další algoritmy,
které se o to pokoušejí.

\subsubsection*{Hašování s pøemísováním}

Seznamy jsou tentokrát ukládány do tabulky a implementovány jako dvousmìrné.
Potøebujeme tedy dvì položky pro práci s tabulkou: \emph{next} -- èíslo øádku
obsahující další prvek seznamu a \emph{previous} -- èíslo øádku obsahující
pøedchozí prvek seznamu. Když dojde ke kolizi, tj. chceme vložit prvek a jeho
místo je obsazené prvkem z jiného øetìzce, pak tento prvek z jiného øetìzce
pøemístíme na jiný prázdný øádek v tabulce (proto hašování s pøemísováním).

\begin{e}{Algoritmus}{0}{Hašování s pøemísováním}
Algoritmus \textbf{MEMBER} funguje stejnì jako u hašování se separovanými
øetìzci, jen místo ukazatele na další prvek použije hodnotu \emph{next} z
tabulky. Pøi operaci \textbf{INSERT} vložíme prvek kam patøí pokud je tam místo,
pokud již je místo obsazeno prvkem který tam patøí, èili zde zaèíná seznam
kolidujících prvkù (\emph{previous} = prázdné), pak postupujeme po položkách
\emph{next} až na konec seznamu, vložíme prvek na nìkterý volný øádek
tabulky a vyplníme správnì hodnoty \emph{next} a \emph{previous}. Pokud je místo
obsazeno prvkem z jiného seznamu (\emph{previous} $\neq$ prázdné), tak tento
prvek pøemístíme na nìkterý volný øádek, správnì pøepíšeme položky \emph{next} a
\emph{previous} v mìnìném seznamu a vkládaný prvek uložíme na jeho místo.
Operace \textbf{DELETE} je vcelku pøímoèará, jenom je tøeba, pokud mažeme první
prvek seznamu na jeho místo pøesunout ten druhý v poøadí (pokud existuje).
\end{e}

\paragraph{Oèekávaný poèet testù} je v neúspìšném pøípadì roven pøibližnì
$(1-\frac{1}{m})^n+\frac{n}{m}\approx e^{-\alpha}+\alpha$ a v úspìšném je stejný
jako pro hašování se separovanými øetìzci a tedy $\frac{n-1}{2m}+1 \approx 1 +
\frac{1}{\alpha}$.

\subsubsection*{Hašování se dvìma ukazateli}

Hašování s pøemísováním má tu nevýhodu, že díky pøemisování prvkù jsou operace
INSERT a DELETE èasovì nároèné. Tato metoda tedy implementuje øetìzce jako
jednosmìrné seznamy, ale takové které nemusejí zaèínat na svém místì, tj.
øetìzec $S_j$ obsahující prvky $s \in S$ takové, že $h(s)=j$, nemusí zaèínat na
$j$-tém øádku. Místo ukazatele na pøedchozí prvek tak do položek pro práci s
tabulkou pøidáme ukazatel na místo, kde zaèíná øetìzec pøíslušný danému øádku.
Položky pro práci s tabulkou tedy budou: \emph{next} -- èíslo øádku tabulky kde
je další prvek seznamu, \emph{begin} -- èíslo øádku tabulky obsahující první
prvek seznamu pøíslušného tomuto místu.

\begin{e}{Algoritmus}{0}{Hašování se dvìma ukazateli}
Položka \emph{begin} v $j$-tém øádku je vyplnìna právì tehdy, když
reprezentovaná množina $S$ obsahuje prvek $s \in S$ takový, že $h(s)=j$.
Algoritmy jsou potom podobné tìm u hašování s pøemísováním, ale pøemísování
prvkù je nahrazeno odpovídajícími zmìnami v položce \emph{begin} daných øádkù.
\end{e}

Díky práci s položkami jsou operace INSERT a DELETE rychlejší než pøi hašování s
pøemísováním, ale zaèátek øetìzce v jiném øádku tabulky pøidá navíc jeden test,
což zmìní složitost operace MEMBER.

\paragraph{Oèekávaný poèet testù} v neúspìšném pøípadì je pøibližnì
$1+\frac{\alpha^2}{2}+\alpha+e^{-\alpha}(2+\alpha)-2$ a pøi úspìšném vyhledávání
je roven $1+\frac{(n-1)(n-2)}{6m^2}+\frac{n-1}{2m} \approx 1 +
\frac{\alpha^2}{6}+\frac{\alpha}{2}$

\subsubsection*{Srùstající hašování}

Nyní se podíváme na nìkolik verzí metody, která se nazývá srùstající hašování.
Budeme potøebovat jedinou položku pro práci s tabulkou a to ukazatel
jednosmìrného spojového seznamu. Na rozdíl od pøedchozích metod zde nejsou
øetìzce separované, v jednom øetìzci mohou být prvky s rùznou hodnotou hašovací
funkce. Když máme pøidat prvek $s$, tak ho zaøadíme do øetìzce, který se nachází
na $h(s)$-tém øádku tabulky. Øetìzce tedy v této metodì \emph{srùstají}. Rùzné
verze této metody se liší tím, kam pøidáváme nový prvek a podle práce s pamìtí.
Dìlí se na \emph{standardní srùstající hašování} bez pomocné pamìti a na hašování
používající pomocnou pamì, kterému se øíká jen \emph{srùstající hašování}.

Nejdøíve se budeme vìnovat metodám standardního srùstajícího hašování (bez
pomocné pamìti):
\begin{pitemize}
\item \textbf{LISCH} -- late-insertion standard coalesced hashing -- vkládá se
za poslední prvek øetìzce,
\item \textbf{EISCH} -- early-insertion standard coalesced hashing -- vkládá se
za první prvek øetìzce.
\end{pitemize}

Pøirozená efektivní operace DELETE pro standardní srùstající hašování není
známa. Na druhou stranu i primitivní algoritmy mají rozumnou oèekávanou èasovou
složitost.

Další otázka zní, proè používat metodu EISCH, když programy pro metodu LISCH
jsou jednodušší. Odpovìï je na první pohled dost pøekvapující. Pøi úspìšném
vyhledávání je metoda EISCH rychlejší než metoda LISCH. Je to proto, že je o
nìco pravdìpodobnìjší, že se bude pracovat s novým prvkem. V neúspìšném pøípadì
jsou samozøejmì obì metody stejné, nebo øetìzce jsou u obou stejnì dlouhé.

Metody srùstajícího hašování (s pomocnou pamìtí) mají použitou pamì rozdìlenou
na dvì èásti. Na tu pøímo adresovatelnou hašovací funkcí a na pomocnou èást.
Adresovací èást má $m$ øádkù, pokud hašovací funkce má hodnoty z oboru
$\{0,1,\dots,m-1\}$, v pomocné èásti jsou øádky ke kterým nemáme pøístup pøes
hašovací funkci. Když pøi pøidávání nového prvku vznikne kolize, tak se nejprve
vybere volný øádek z pomocné èásti a teprve když je pomocné èást zaplnìna
použijí se k ukládání kolidujících prvkù øádky z adresovatelné èásti tabulky.
Tato strategie oddaluje srùstání øetìzcù. Srùstající hašování se tedy, aspoò
dokud není zaplnìna pomocná èást tabulky, podobá hašování se separovanými
øetìzci. Existují základní tøi varianty:
\begin{pitemize}
\item \textbf{LICH} -- late-insertion coalesced hashing -- vkládá prvek na konec
øetìzce,
\item \textbf{VICH} -- early-insertion coalesced hashing -- vkládá prvek na
øádek $h(x)$ pokud je prázdný a nebo hned za prvek na øádku $h(x)$,
\item \textbf{EICH} -- varied-insertion coalesced hashing -- vkládá se za
poslední prvek øetìzce, který je ještì v pomocné èásti. Pokud v pomocné èásti
žádný není, vkládá se hned za prvek na pozici $h(x)$.
\end{pitemize}

Tyto metody nepodporují pøirozené efektivní algoritmy pro operaci DELETE.

\subsubsection*{Hašování s lineárním pøidáváním}

Následující metoda nepoužívá žádné položky pro práci s tabulkou to znamená, že
zpùsob nalezení dalšího øádku øetìzce je zabudován pøímo do metody. Metoda
funguje tak, že pokud chceme vložit prvek do tabulky a nastane kolize, najdeme
první následující volný øádek a tam prvek vložíme. Pøedpokládáme, že øádky jsou
èíslovány modulo \emph{m}, èili vytváøejí cyklus délky \emph{m}.

Tato metoda sice využívá minimální velikost pamìti, ale v tabulce vznikají
shluky obsazených øádkù a proto je pøi velkém zaplnìní pomalá. Navíc metoda
nepodporuje efektivní operaci DELETE.

\subsubsection*{Shrnutí}

Zde uvedeme poøadí metod hašování podle oèekávaného poètu testù.

\begin{obecne}{Neúspìšné vyhledávání:}
\begin{penumerate}
\item Hašování s uspoøádanými separovanými øetìzci,
\item Hašování se separovanými øetìzci = Hašování s pøemísováním,
\item Hašování se dvìma ukazateli,
\item VICH = LICH
\item EICH,
\item LISCH = EISCH,
\item Hašování s lineárním pøidáváním.
\end{penumerate}
\end{obecne}

\begin{obecne}{Úspìšné vyhledávání}
\begin{penumerate}
\item H. s uspoøádanými øetìzci = H. se separovanými øetìzci = H. s pøemísováním,
\item Hašování se dvìma ukazateli,
\item VICH,
\item LICH,
\item EICH,
\item EISCH,
\item LISCH,
\item Hašování s lineárním pøidáváním.
\end{penumerate}
\end{obecne}

\begin{e}{Poznámka}{0}{0} Metody se separovanými øetìzci a srùstající hašování používají
více pamìti. Metoda s pøemísováním vyžaduje více èasu -- na pøemístìní prvku.
Otázka která z metod je nejlepší není proto jednoznaènì rozhodnutelná a je nutné
peèlivì zvážit všechny okolnosti nasazení metody a všechny naše požadavky na ní,
než se rozhodneme, kterou použijeme.
\end{e}

\subsubsection*{Univerzální hašování}

Pro dobré fungování hašování potøebujeme mimo jiné, aby vstupní data byla
rovnomìrnì rozdìlena a toho nìkdy není možné dosáhnout. Odstranit tento
nedostatek se pokouší metoda \emph{univerzální hašování}. Základní idea této
metody je taková, že máme množinu \emph{H} hašovacích funkcí z univerza do
tabulky velikosti \emph{m} takových, že pro $S \subseteq U$, $|S| \leq m$ se
vìtšina funkcí chová dobøe v tom smyslu, že má malý poèet kolizí. Hašovací
funkci potom zvolíme z množiny \emph{H} (takovou s rovnomìrným rozdìlením).
Jelikož funkci volíme my, mùžeme požadavek rovnomìrného rozdìlení zajistit.

\subsubsection*{Perfektní hašování}

Jiná možnost jak vyøešit kolize, je najít takzvanou \emph{perfektní hašovací
funkci}, tj. takovou které nepøipouští kolize. Nevýhoda této metody je, že nelze
dost dobøe implementovat operaci INSERT, proto se dá prakticky použít pouze tam,
kde pøedpokládáme hodnì operací MEMBER a jen velmi málo operací INSERT. Kolize
se potom dají øešit tøeba malou pomocnou tabulkou, kam se ukládají kolidující
data. 

Pro rozumné fungování metody je nutné, aby hašovací funkce byla rychle
spoèitatelná a aby její zadání nevyžadovat mnoho pamìti, nejvýhodnìjší je
analytické zadání. 

Naopak jedna z výhod je, že nalezení perfektní hašovací funkce, mùže trvat
dlouho, nebo ho provádíme pouze jednou na zaèátku algoritmu. 

\subsubsection*{Externí hašování}

Externí hašování øeší trochu jiný problém, než výše popsané metody. Chceme
uložit data na externí médium a protože pøístup k externím médiím je o nìkolik
øádù pomalejší, než práce v interní pamìti, bude naším cílem minimalizovat poèet
pøístupù do ní. Externí pamì bývá rozdìlena na stránky a ty vìtšinou naèítáme
do interní pamìti celé. Tato operace je však velice pomalá. Problémem externího
hašování je tedy nalézt datovou strukturu pro uložení dat na vnìjší pamìti a
algoritmy pro operace INSERT, DELETE a MEMBER, tak abychom použili co nejmenší
poèet komunikací mezi vnìjší a vnitøní pamìtí.

Metod externího hašování je opìt mnoho. Nìkteré používají pomocnou datovou
strukturu v interní pamìti, kterou èasto nazýváme adresáø. Pokud metody nemají
žádnou takovou pomocnou strukturu neobejdou se obvykle bez oblasti pøeteèení.
Nìkteré známìjší metody vnìjšího hašování jsou napøíklad: \uv{Litwinovo lineární
hašování}, \uv{Faginovo rozšiøitelné hašování}, \uv{Cormackovo perfektní
hašování} nebo \uv{Perfektní hašování Larsona a Kajli}. 
% to neni preklep, hasovani je opravdu od pana KAJLI z nakyho duvodu se to uci
% blbe. viz http://portal.acm.org/citation.cfm?id=358193&coll=portal&dl=ACM
% ajs
