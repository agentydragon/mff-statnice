\def\Real{ \mathbb{R} }

\subsection{Grafové algoritmy}

TODO: nejake vyuziti tech algoritmu (staci priklad plusminus ke kazdemu druhu ulohy)

\subsubsection*{Graf}

\begin{e}{Definice}{0}{0}
\emph{Graf} $G$ je dvojice $(V,E)$, kde $V$ je mnoina bodù (\emph{vrcholù}) a $E$ mnoina jejich dvojic (\emph{hran}). Je-li $E$ mnoinou neuspoøadanıch dvojic, jde o \emph{neorientovanı} graf. Jsou-li dvojice uspoøádané, jedná se o \emph{orientovanı} graf. Velikost mnoiny $V$ se znaèí $n$, velikost $E$ je $m$ - $|V|=n$, $|E|=m$.

Graf je moné strojovì reprezentovat napø. pomocí \emph{matice sousednosti} -- matice, kde je na souøadnicích $(u,v)$ hodnota $1$, pokud z $u$ do $v$ je hrana a $0$ jinak. Pro neorientované grafy je soumìrná podle hlavní osy. Matice zabírá $\Theta(n^2)$ místa v pamìti. Další moností jsou \emph{seznamy sousedù} -- dvì pole, jedno pøíslušné vrcholùm, druhé hranám. V prvním jsou uloené indexy do druhého pole, urèující kde zaèínají seznamy hran vedoucích z vrcholu (pøíslušejícímu k indexu v prvním poli). Pamìová nároènost je $\Theta(m+n)$.
\end{e}

\subsubsection*{Prohledávání do hloubky a do šíøky}

Algoritmy, které postupnì projdou všechny vrcholy daného souvislého neorientovaného grafu.

\begin{e}{Algoritmus}{0}{Prohledávání do šíøky/Breadth-First Search}
Prochází všechny vrcholy grafu postupnì po vrstvách vzdáleností od iniciálního vrcholu. K implementaci se pouívá fronta (FIFO).

\begin{verbatim}
BFS( V - vrcholy, E - hrany, s - startovací vrchol ){
  obarvi vrcholy bíle, nastav jim nekoneènou vzdálenost od s a pøedchùdce NULL;
  dej do fronty vrchol s;

  while( neprázdná fronta ){
    vyber z fronty vrchol v;
    foreach( všechny bíle obarvené sousedy v = u ){
       obarvi u šedì a nastav mu vzdálenost d(v) + 1 a pøedchùdce v;
       dej vrchol u do fronty;
    }
    v pøebarvi na èerno a vyhoï z fronty.
  }
}
\end{verbatim}


Bìí v èase $\Theta(m+n)$, protoe kadı vrchol testuje 2x pro kadou hranu, do fronty ho dává 1x a obarvení mu mìní 2x. Tento algoritmus je základem nìkolika dalších, napø. pro testování souvislosti grafu, hledání minimální kostry nebo nejkratší cesty.
\end{e}

\begin{e}{Algoritmus}{0}{Prohledávání do hloubky/Depth-First Search}
Prochází postupnì všechny vrcholy - do hloubky (pro kadı vrchol nejdøív navštíví první jeho nenavštívenı sousední vrchol, pak první sousední tohoto vrcholu atp. a dojde k vrcholu bez nenavštívenıch sousedù, pak se vrací a prochází další ještì nenavštívené sousedy). Pro implementaci se pouívá buï zásobník, nebo rekurze. Zásobníková verze vypadá stejnì jako prohledávání do šíøky (místo fronty je zásobník).

Rekurzivní verze - pøi zavolání na startovní vrchol projde celı graf:
\begin{verbatim}
DFS(v - vrchol){

  oznaè v jako navštívenı;
  foreach( všechny nenavštívené sousedy v = u )
     DFS( u );
}
\end{verbatim}

Èasová sloitost je $\Theta(m+n)$, stejnì jako u prohledávání do šíøky.
\end{e}


\subsubsection*{Souvislost}

\begin{e}{Definice}{0}{0}
\emph{Cesta} v grafu $G=(V,E)$ z vrcholu $a$ do vrcholu $b$ je posloupnost $v_0,v_1,\dots,v_n$ taková, e $v_0=a$, $v_n=b$ a pro všechna $v_i$, $i\in\{1,\dots,n\}$ je $(v_{i-1},v_i)\in E$. Graf $G=(V,E)$ je \emph{souvislı}, pokud pro kadé dva vrcholy $u,v\in V$ existuje v $G$ cesta z $u$ do $v$. Toto platí pro orientované i neorientované grafy.
\end{e}

\begin{e}{Algoritmus}{0}{Testování souvislosti grafu/poèítání komponent souvislosti}
Algoritmus vyuívá prohledávání do šíøky (nebo do hloubky) - v 1 kroku vdy najde dosud nenavštívenı vrchol, zaène z nìj procházet graf a takto projde(oddìlí) jednu komponentu souvislosti. Pokud skonèí po prvním kroku, graf je souvislı. Poèet krokù, potøebnıch k navštívení všech vrcholù grafu, je zároveò poètem komponent souvislosti.

Èasová sloitost je $\Theta(m+n)$, protoe o algoritmu platí to samé co o prohledávání do šíøky -- ádnı vrchol nebude pøidán do fronty více ne jednou a testován více ne 2x pro kadou hranu.
\end{e}


\subsubsection*{Topologické tøídìní}

\begin{e}{Definice}{0}{0}
\emph{Topologické uspoøádání} vrcholù orientovaného grafu $G=(V,\overrightarrow{E})$ je funkce $t:V\to \{1,\dots,n\}$ taková, e pro kadou hranu $(i,j)\in E$ je $t(i)<t(j)$. Lze provést pouze pro acyklické orientované grafy.
\end{e}

\begin{e}{Algoritmus}{0}{Primitivní algoritmus}
V kadém kroku najde vrchol, z nìho nevedou ádné hrany. Pøiøadí mu nejvyšší volné èíslo (zaèíná od $n$) a odstraní ho ze seznamu vrcholù. Uspoøádání takto vytvoøené je topologické, sloitost algoritmu je $\Theta(n(m+n))$.
\end{e}

\begin{e}{Algoritmus}{0}{Rychlı algoritmus}
K topologickému uspoøádání se dá pouít modifikace prohledávání do hloubky. Není tøeba ani graf pøedem testovat na pøítomnost cyklù, algoritmus toto objeví. Pro kadı navštívenı vrchol si poznamená èas jeho opuštìní, uspoøádání podle klesajících èasù opuštìní je topologické.
\begin{verbatim}
topologické_tøídìní( v - vrchol ) {

  global t; // èas opuštìní, iniciální hodnota 0

  oznaè v jako navštívenı;
  foreach ( u in sousední vrcholy v ) {
    if ( u je navštívenı, ale ne opuštìnı ) {
      chyba - cyklus;
      return;
    }
    else if ( u není navštívenı )
      topologické_tøídìní( u );
  }
  oznaè v jako opuštìnı v èase t;
  t = t + 1;
}
\end{verbatim}
Èasová sloitost zùstává stejná jako u prohledávání do šíøky, tedy $\Theta(m+n)$, protoe všechny kroky provádìné v rámci navštívení 1 vrcholu vyadují jen konstatní poèet operací.
\end{e}

\begin{e}{Poznámka}{0}{0}
Topologické tøídìní se pouívá napø. k zjištìní nejvhodnìjšího poøadí provedení navzájem závislıch èinností.
\end{e}

\subsubsection*{Hledání nejkratší cesty v grafu}

\begin{e}{Definice}{0}{0}
\emph{Ohodnocení hran - váhová funkce} je funkce, která kadé (orientované) hranì pøiøazuje její \uv{délku} nebo \uv{cenu} jejího projití. Definuje se jako $w:E\to\Real$. \emph{Délka} (orientované) \emph{cesty} $p=v_0,v_1\dots,v_n$ v ohodnoceném grafu (grafu s váhovou funkcí) je potom $w(p)=\sum_{i=1}^n w(v_{i-1},v_i)$.

\emph{Vzdálenost} dvou vrcholù $u,v$ (\emph{váha nejkr. cesty} z $u$ do $v$) je $\delta(u,v) = \min\{ w(p)| p$ je cesta z $u \mbox{ do } v \}$, pokud nìjaká cesta z $u$ do $v$ existuje, jinak $\delta(u,v)=\infty$. \emph{Nejkratší cesta} $p$ z $u$ do $v$ je taková, pro kterou $w(p)=\delta(u,v)$.
\end{e}

\begin{e}{Poznámka}{0}{0}
Pro hledání nejkratší cesty v obecném grafu bez ohodnocení hran (tj. délka cesty je poèet hran na ní) staèí prohledávání do šíøky.
\end{e}

\begin{e}{Algoritmus}{0}{Algoritmus kritické cesty (pro DAG)}
Pro hledání nejkratší cesty do všech bodù z jednoho zdroje v orientovaném acyklickém grafu (DAG) pouívá topologické tøídìní, které je pro takovıto graf proveditelné; spolu se zpøesòováním horních odhadù vzdáleností vrcholù.

Mám danı startovací vrchol $s$. Definuji $d(s,v)$ jako horní odhad vzdálenosti $s$ a $v$, tj. vdy $d(s,v)\geq\delta(s,v)$ pro lib. vrchol $v$. Hodnoty $d(s,v)$ pøed zapoèetím vıpoètu inicializuji na $+\infty$.

V algoritmu se provádí operace \uv{Relax}, znamenající zpøesnìní odhadu $d(s,v)$ za pouití cesty vedoucí z $s$ do $v$, konèící hranou $(u,v)$ -- pokud má taková cesta niší váhu ne byl pøedchozí odhad $d(s,v)$, poloím $d(s,v)=d(s,u)+w(u,v)$. Tato operace zachovává invariant $d(s,v)\geq\delta(s,v)$.

\begin{verbatim}
Relax (u, v) { //u = source, v = destination
  if (v.distance > u.distance + uv.weight) {
    v.distance := u.distance + uv.weight
    v.predecessor := u
  }
}
\end{verbatim}

\begin{verbatim}
kritická cesta( V - vrcholy, E - hrany, s - startovací vrchol ){

  topologicky setøiï V;
  inicializace - nastav d(s,v) = nekoneèno pro všechny vrcholy;
  foreach( vrchol v, v poøadí podle top. tøídìní ){
    proveï operaci Relax za pouití cest
        vedoucích do v pøes všechna moná u;
  }
}
\end{verbatim}

Vısledek dává nejkratší cesty díky topologickému setøídìní grafu -- pro nejkr. cestu $p$ z $s$ do $v$ platí $t(v_i)<t(v_{i+1})$ a pokud mám $d(s,u)=\delta(s,u)$ a provedu Relax na $v$ podle $(u,v)$, pak dostanu $d(s,v)=\delta(s,v)$, z èeho se korektnost dá dokázat indukcí podle poètu hran na cestì.

Sloitost algoritmu je $\Theta(n+m)$, protoe taková je sloitost topologického tøídìní a zbytek algoritmu kadou hranu i kadı vrchol testuje právì 1x.
\end{e}

\begin{e}{Algoritmus}{0}{Dijkstrùv algoritmus}
Pracuje na libovolném orientovaném grafu s nezápornım ohodnocením hran.
\begin{verbatim}
Dijkstra( V - vrcholy, E - hrany, s - startovací vrchol ){

   inicializace - nastav d(s,v) = nekoneèno pro všechny vrcholy;
   S = prázdnı; // mnoina "vyøízenıch" vrcholù
   Q = V; // mnoina "nevyøízenıch" vrcholù

   while( Q není prázdná ){
      vyber u, vrchol s nejmenším d z mnoiny Q;
      vlo vrchol u do S;
      foreach( v, z u do v vede hrana )
        proveï operaci Relax pro v pøes u;
   }
}
\end{verbatim}
Èasová sloitost pøi implementaci mnoin $S$ a $Q$ pomocí haldy je: $\Theta(n\cdot\log n)$ pro inicializaci ($n$ vloení do haldy), $\Theta(n\cdot\log n)$ celkem pro vybírání prvkù s nejmenším $d$, jedno provedení Relax pøi zmìnì $d$ trvá $\Theta(\log n)$ (úprava haldy) a provede se max. $m$-krát; tedy celkem $\Theta((m+n)\cdot\log n$).
\end{e}

\begin{e}{Algoritmus}{0}{Bellman-Ford}
Bellman-Fordùv algoritmus lze pouít nejobecnìji, ale je nejpomalejší. Funguje na libovolném grafu (pokud najde cyklus, jeho celková váha je záporná, a tedy nejkratší cesty nemají smysl, vrací chybu).

\begin{verbatim}
Bellman-Ford( V - vrcholy, E - hrany, s - startovací vrchol ){

  inicializace - nastav d(s,v) = nekoneèno pro všechny vrcholy;
  d(s,s) = 0;
  
  // n-1 iterací, kadá projde všechny hrany
  for( i = 1; i < |V|; ++i ) {
    foreach( hrana (u,v) z E )
      proveï operaci Relax pro v pøes u;
  }

  // hledání záporného cyklu
  foreach( hrana (u,v) z E ){
    if ( d(v) > d(u) + w(u,v) ){
      chyba - zápornı cyklus;
      return;
    }
  }
}
\end{verbatim}

Sloitost algoritmu je $\Theta(m\cdot n)$. Vdy najde nejkratší cestu, protoe v grafu bez zápornıch cyklù mùe mít cesta max. $n-17K\check{c} (1 $) vrcholù. Dùkaz nalezení záporného cyklu sporem, se sumou vah všech hran na nìm (poloím $<0 K\check{c} ($ 0)).
\end{e}

\begin{e}{Poznámka}{0}{Nejkratší cesty pro všechny dvojice vrcholù}
Pro hledání nejkratších cest pro všechny dvojice vrcholù lze buï pouít $n$-krát bìh nìkterého z pøedchozích algoritmù, nebo \emph{Algoritmus \uv{násobení matic}} èi \emph{Floyd-Warshallùv algoritmus}. Ty oba pouívají matice sousednosti $W_G$ a poèítají matici vzdáleností $D_G$.

První z nich postupuje indukcí podle poètu hran na nejkr. cestì, vyrábí matice $D_G(x)$ pro $x$ hran na nejkratší cestì. $D_G(1)$ je $W_G$, pro vıpoèet kroku $i$ vdy $D_G(i-1)$ \uv{vynásobí} $D_G(1)$ pouitím zvláštního \uv{násobení}, kde násobení hodnot je nahrazeno sèítáním a sèítání vıbìrem minima. Sloitost je s vyuitím asociativity takto definovaného \uv{násobení} $\Theta(n^3\log n)$.

Floyd-Warshallùv algoritmus jde indukcí podle velikosti mnoiny vrcholù, povolenıch jako vnitøní vrcholy na cestách. Pouívá $d_{u,v}(k)$ jako min. váhu cesty z $u$ do $v$ s vnitø. vrcholy z mnoiny $\{1,\dots,k\}$. V iniciálním kroku je taky $D_G(1)=W(G)$. Pro $i$-tı krok je $d_{u,v}(i)=\min\{d_{u,v}(i-1),d_{u,i}(i-1)+d_{i,v}(i-1)\}$. Sloitost je $\Theta(n^3)$, navíc jeden krok je velice rychlı -- celkovì je algoritmus vìtšinou rychlejší ne Bellman-Fordùv a pro záporné cykly se èasem na diagonále objeví záp. èíslo, proto je není tøeba testovat pøedem.
\end{e}

\subsubsection*{Minimální kostra grafu}

Úkolem v této úloze je najít kostru $T$ (acyklickı souvislı podgraf) grafu $(V,E)$ s celkovou minimální vahou hran. Vdy platí $|T|=|V|-17K\check{c} (1 $). Bez újmy na obecnosti lze pøedpokládat, e ohodnocení hran jsou nezáporná (lze ke všem pøièíst konstantu a vısledek se nezmìní).

\begin{e}{Algoritmus}{0}{Borùvkùv / Kruskalùv algoritmus}
\begin{verbatim}
Borùvka( V - vrcholy, E - hrany ){

  S = setøídìné hrany podle jejich váhy;
  pøiøaï vrcholùm èísla komponent souvislosti;
  F = {}; // tj. (V,F) je "les", kde kadı vrchol je
               // jedna komponenta souvislosti
  
  while( S není prázdná ){
    vyber z S další hranu (x,y);
    if ( èíslo komponenty x != èíslo komponenty y ){
      F += (x,y);
      slij komponenty pøíslušné k x a y;
    }
  }
  return ( (V,F) jako minimální kostru (v,E) );
}
\end{verbatim}

Celková sloitost je $\Theta(m\log m)$ pøi pouití spojovıch seznamù: Setøídìní hran podle váhy $\Theta(m\log m)$, nalezení èísla komponenty konstantní èas, max. poèet pøeèíslování komponent pøi slévání (pøeèíslovávám-li vdy menší ze slévanıch komponent) pro 1 vrchol je $\Theta(\log n)$, tj. celkem $\Theta(n\log n)$.

Algoritmus je korektní - vdy nalezne kostru, protoe pøidá právì $|V|-17K\check{c} (1 $) hran a nevytvoøí nikdy cyklus. Minimalita kostry se dokáe sporem -- mám-li $F$ vrácenou algoritmem a $H$ nìjakou min. kostru, tak pokud je $w(F)>w(H)$, najdu hranu $e\in F\setminus H$, vezmu kostru $H_1=H\cup e\setminus f$ (a $w(e)\leq w(f)$). Pokud mám $\forall e$ nalezené $f$ takové, e $w(e)=w(f)$, jsou $F$ i $H$ minimální, jinak $H$ taky nebylo minimální, protoe $H_17K\check{c} (1 $) je menší.
\end{e}

\begin{e}{Algoritmus}{0}{Jarníkùv / Primùv algoritmus }
\begin{verbatim}
Jarník( V - vrcholy, E - hrany, r - startovní vrchol ){

  Q = V; // mnoina pouívanıch vrcholù, dosud nepøipojenıch
          // ke kostøe
  F = {}; // vznikající kostra, v kadém okamiku
          // je strom

  inicializace - nastav klíè(v) na nekoneèno
      pro všechny vrcholy;
  klíè(r) = 0;
  soused(r) = NULL;

  while( Q je neprázdná ){
    vyber u, prvek s nejmenším klíèem z Q;
    F += ( soused(u),u );
    foreach( vrchol v, z u do v vede hrana ){
      if ( v je v Q a klíè(v) > w(u,v) ){
         klíè(v) = w(u,v);
         soused(v) = u;
      }
    }
  }
  return ( (V,F) jako min. kostru (V,E) );
}
\end{verbatim}

Sloitost algoritmu je $\Theta(m\log n)$, pokud je $Q$ reprezentováno jako bin. halda - nejvıše $m$-krát upravuji klíè nìjakého vrcholu, co má v haldì sloitost $\Theta(\log n)$, vıbìr minima max. $n$-krát $\Theta(\log n)$ a inicializace jen $\Theta(n)$.

Vytvoøenı graf je kostra, protoe nikdy nevzniká cyklus (pøipojuji právì vrcholy z $Q$, která je na konci prázdná). Dùkaz minimality podle konstrukce -- najdu první hranu $e$ v min. kostøe $H$, která není ve vısledku alg. $F$, pak najdu $f\in H$, t.. $F\setminus e\cup f$ je kostra, z algoritmu je $w(f)\geq w(e)$. Vezmu $H_1=H\setminus f\cup e$, vím, e $w(H_1)\leq w(H)$ a tedy $H_17K\check{c} (1 $) je min. kostra, iterací tohoto postupnì dostanu, e $H_k=F$ je min. kostra.
\end{e}


\subsubsection*{Toky v sítích}

\emph{není poadaváno v IP a ISPS}

\begin{e}{Definice}{0}{Sí, tok}
\emph{Sí} je ètveøice $(G,z,s,c)$, kde $G$ je (orientovanı) graf, $z$ zdrojovı a $s$ cílovı vrchol (stok, spotøebiè) a $c:E\to\Real^{+}$ funkce kapacity hran. \emph{Tok} sítí je taková funkce $t:E\to\Real^{+}$, e pro kadou hranu $(u,v)$ je 0Kè ($ 0)\leq t((u,v))\leq c((u,v))$ a navíc pro kadı vrchol $v$ kromì $z$ a $s$ (\emph{uzel sítì}) platí $\sum_{e=(u,v)}t(e) = \sum_{e=(v,w)}t(e)$ (tj. \emph{pøebytek toku} - rozdíl toho co do vrcholu vteèe a co z nìj odteèe $\delta(t,v)$ je pro uzly sítì nulovı). \emph{Velikost toku} se definuje jako $|t|=\delta(t,s)$.
\end{e}

\begin{e}{Algoritmus}{0}{Ford-Fulkersonùv algoritmus}
Algoritmus pouívá myšlenku zlepšitelné cesty - tj. pokud existuje v grafu neorientovaná cesta ze $z$ do $s$ taková, e pro hrany ve smìru od zdroje je $t<c$ a pro hrany ve smìru ke zdroji $t>0K\check{c} (0 $), pak mohu tok zlepšit (o minimum rezerv). Algoritmus opakuje takovıto krok, dokud je moné ho provést. Neøeší vıbìr cesty, proto je dost pomalı a pokud nejsou hodnoty $t$ racionální èísla, mùe se i zacyklit.

Ve chvíli zastavení algoritmu získám max. tok, nebo mnoina $A=\{ v|$ ze $z$ do $v$ vede zlepšitelná cesta $\}$ je v tom okamiku \emph{øez} (mnoina $A\subset V$ taková, e $z\in V$, $s\notin V$) a jeho \emph{velikost} ($\sum_{e\in E}c(e),e=(u,v),u\in A,v\notin A$) je stejná jako velikost získaného toku.
\end{e}


\begin{e}{Algoritmus}{0}{Dinitzùv algoritmus}
Øeší vıbìr zlepšitelné cesty -- vybírá vdy nejkratší cestu (co obecnì popisuje \emph{Edmunds-Karpùv algoritmus}). Dinitzova varianta pouívá \emph{sí rezerv}, co je graf $(V,R)$, kde hrana $e=(v,w)\in R$, pokud má tok hranou kladnou \emph{rezervu}, tj. $r = c(v,w)-t(v,w)+t(w,v) > 0K\check{c} (0 $). Zlepšující cesta odpovídá normální orientované cestì v síti rezerv. Pøevod na pùv. graf ze sítì rezerv je jednoduchı, mohu pøedpokládat, e jedním ze smìrù mezi dvìma vrcholy neteèe nic.

Prùbìh algoritmu: na zaèátku nastaví všem hranám rezervu $r(v,w)=c(v,w)$. Potom postupuje po \emph{fázích} - v 1 fázi:
\begin{pitemize}
\item Vyhodí ze sítì rezerv všechny hrany, které nejsou na nejkratší cestì $z\to s$ (2x prohledávání do šíøky).
\item Vezme jednu z nejkr. cest v síti rezerv a zlepší podle ní tok.
\item Vyhodí vzniklé slepé cesty v síti rezerv (testuji jen hrany, co vyhazuji, a jejich konc. vrcholy)
\item Toto opakuje, dokud jsou v síti rezerv cesty $z\to s$ dané nejkratší délky.
\end{pitemize}
Další fází algoritmus pokraèuje, dokud existuje vùbec nìjaká cesta $z\to s$ v síti rezerv. Fází je tím pádem max. $n$ (max. délka cesty ze $z$ do $s$), v 1 fázi se prochází max. $m$ cest (klesá poèet pouitelnıch hran), nalezení 1 cesty je $O(n)$ (jdu pøímo) a vyhazování slepıch cest max $O(m)$ celkem za fázi (kadou hranu vyhodím jen jednou). Celková sloitost je tedy $O(n^2 m)$.
\end{e}


\begin{e}{Algoritmus}{0}{Goldbergùv algoritmus (preflow-push, algoritmus vlny)}
Nehledá v grafu zlepšující cesty, v prùbìhu vıpoètu v grafu není tok, ale vlna (ze zdroje teèe vdy více nebo rovno ne max. tok). \emph{Preflow} -- \uv{vlna} -- je funkce $t:E\to\Real^{+}$ taková, e $\forall e\in E: 0\leq t(e)\leq c(e)$, tedy pøebytky toku ve vrcholech ($\delta$) jsou povolené. Ve chvíli, kdy ádnı vrchol nemá pøebytek toku ($\delta$), dostávám (maximální) tok. Pro kadı vrchol $v$ si algoritmus pamatuje \uv{vıšku} $h(v)$. Také pracuje se sítí rezerv.
\begin{pitemize}
    \item \emph{Inicializace}: $h(z)=n$, $h(v,v\neq z)=0K\check{c} (0 $), $t(e)=0\ \forall e$, $\delta(v)=0\ \forall v$.
    \item \emph{Úvodní preflow}: pøevede ze zdroje maximum moného ($t(e)=c(e)$ po smìru) do sousedních vrcholù.
    \item \emph{Hlavní cyklus}: opakuje se, dokud existuje vnitøní vrchol $v$ s kladnım $\delta$. pro vrchol $v$:
    \begin{pitemize}
        \item pokud existuje hrana $(v,w)$ nebo $(w,v)$, t.. $r(e) > 0K\check{c} (0 $) (v daném smìru) a $h(v)\geq h(w)$, potom se pøevede $\min(\delta(v),r(e))$ z $v$ do $w$.
\item jinak se zvıší $h(v)$ o 1.
    \end{pitemize}
\end{pitemize}

Po celou dobu bìhu algoritmu platí invariant $e=(v,w),r(e)>0\ \Rightarrow\ h(v)\leq 1+h(w)$. To zaruèuje, e nalezenı tok po zastavení je maximální (zdroj je ve vıšce $n$, stok $0$, tedy kadá cesta pøekonává nìkde rozdíl $-33K\check{c} (2 $)). Vrcholy nejde zvedat donekoneèna, take se algoritmus zastaví: pro kadı vnitøní vrchol $v$ platí, e je-li $\delta(v)>0K\check{c} (0 $), pak existuje v síti rezerv cesta $v\to z$. To zaruèuje, e $h(v)\leq 2n-17K\check{c} (1 $) - pokud mám vrchol $v$ tak, e $h(v)=2n-17K\check{c} (1 $) a $\delta(v)>0K\check{c} (0 $), potom existuje cesta $v\to z$ s kladnımi rezervami a podle invariantu jde kadá hrana na ní max. o 1 nahoru (tedy max. o $n-17K\check{c} (1 $) celkem).

Sloitost Goldbergova algoritmu je $O(n^2\cdot m)$.
\end{e}

