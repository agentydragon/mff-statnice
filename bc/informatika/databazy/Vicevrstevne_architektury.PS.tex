\subsection{Vícevrstevné architektury}

TODO: pøedìlat, tohle je jen copy \& paste z Wiki a slajdù VUT Brno


\begin{obecne}{Multitier architecture}
Multi-tier architecture (often referred to as n-tier architecture) is a client-server architecture, originally designed by Jonathon Bolster of Hematites Corp, in which an application is executed by more than one distinct software agent. For example, an application that uses middleware to service data requests between a user and a database employs multi-tier architecture. The most widespread use of "multi-tier architecture" refers to three-tier architecture
\end{obecne}


\begin{obecne}{Základ kooperativního zpracování}
Faktory ovlivòující architekturu:
\begin{pitemize}
\item poadavky na interoperabilitu zdrojù 
\item rùst velikosti zdrojù 
\item rùst poètu klientù 
\end{pitemize}
Typy slueb v databázové technologii:
\begin{pitemize}
\item prezentaèní sluby: pøíjem vstupu, zobrazování vısledkù 
\item prezentaèní logika: øízení interakce (hierarchie menu, obrazovek)
\item logika aplikace: operace realizující algoritmus aplikace
\item logika dat: podpora operací s daty (integritní omezení, ...)
\item datové sluby: akce s databází (definice a manipulace, transakèní zpracování, ...) 
\item sluby ovládání souborù: vlastní V/V operace
\end{pitemize}
\end{obecne}

\begin{obecne}{Varianty architektury klient-server}
\begin{pitemize}
    \item \textbf{Klient-server se vzdálenımi daty} \\
Na serveru jsou jen datové sluby a ovládání souborù, zbytek zajišují klienti. Problémem jsou velké nároky na pøenosovu kapacitu od klienta k serveru a HW zatíení klientskıch stanic
    \item \textbf{Klient-server se vzdálenou prezentací} \\
Na klientské stanici jsou jen prezentaèní sluby a prezentaèní logika, zbytek je na serveru. Nevıhodou je právì zátì na HW serveru.
    \item \textbf{Klient-server s rozdìlenou logikou} \\
Èást logiky aplikací i logiky dat je na serveru a èást zpracovává klient. Jde o vyváené øešení, které má ale horší rozšíøitelnost.
    \item \textbf{Tøívrstvá architektura} \\
Zahrnuje dva servery -- aplikaèní a databázovı, spojené rychlou linkou. Z hlediska zátìe a rozšíøitelnosti nejvıhodnìjší.
\end{pitemize}
\end{obecne}

\begin{obecne}{Pøínos architektury klient/server a tøívrstvé architektury}
\begin{pitemize}
 \item prunìjší rozdìlení práce \item lze pouít horizontální(více serverù) i vertikální(vıkonnìjší server) škálování \item aplikace mohou bìet na levnìjších zaøízeních \item na klientskıch stanicích lze pouívat oblíbenı prezentaèní software \item standardizovanı pøístup umoòuje zpøístupnit další zdroje \item centralizace dat podporuje úèinnìjší ochranu \item u tøívrstvé architektury centralizace údrby aplikace, monost vyuití sdílenıch objektù (business objects) nìkolika aplikacemi
\end{pitemize}
\end{obecne}

\begin{obecne}{Podpora pro rozdìlení zátìe v architektuøe klient/server}
\begin{pitemize}
 \item deklarativní integritní omezení \item databázové triggery \item uloené podprogramy
\end{pitemize}
\end{obecne}


\begin{obecne}{Three-tier architecture}
'Three-tier' is a client-server architecture in which the user interface, functional process logic ("business rules"), data storage and data access are developed and maintained as independent modules, most often on separate platforms. The term "three-tier" or "three-layer", as well as the concept of multitier architectures, seems to have originated within Rational Software.

The three-tier model is considered to be a software architecture and a software design pattern.

Apart from the usual advantages of modular software with well defined interfaces, the three-tier architecture is intended to allow any of the three tiers to be upgraded or replaced independently as requirements or technology change. For example, a change of operating system from Microsoft Windows to Unix would only affect the user interface code.

Typically, the user interface runs on a desktop PC or workstation and uses a standard graphical user interface, functional process logic may consist of one or more separate modules running on a workstation or application server, and an RDBMS on a database server or mainframe contains the data storage logic. The middle tier may be multi-tiered itself (in which case the overall architecture is called an "n-tier architecture").

The 3-Tier architecture has the following 3-tiers:
\begin{pitemize}
    \item Presentation Tier
    \item Application Tier/Logic Tier/Business Logic Tier
    \item Data Tier
\end{pitemize}
\end{obecne}


\begin{obecne}{Web Development usage}

In the Web development field, three-tier is often used to refer to Websites, commonly Electronic commerce websites, which are built using three tiers:
\begin{pitemize}
    \item A front end Web server serving static content
    \item A middle dynamic content processing and generation level Application server, for example Java EE platform.
    \item A back end Database, comprising both data sets and the Database management system or RDBMS software that manages and provides access to the data.
\end{pitemize}
\end{obecne}

\begin{obecne}{Other Considerations}

To further confuse issues, the particular data transfer method between the 3 tiers must also be considered. The data exchange may be file-based, client-server, event-based, etc. Protocols involved may include one or more of SNMP, CORBA, Java RMI, Sockets, UDP, or other proprietary combinations/permutations of the above types and others. Typically a single "middle-ware" implementation of a single protocol is chosen as the "standard" within a given system, such as J2EE (which is Java specific) or CORBA (which is language/OS neutral.) The importance of the decision of which protocol is chosen affects such issues as the ability to include legacy applications/libraries, performance, maintainability, etc. When choosing a "middle-ware protocol" (not to be confused with the "middle-of-the-three-tiers") engineers should not be swayed by "public opinion" about a protocol's modern-ness, but should consider the technical benefits and suitability to solve a problem. (for example CGI is very old and "out of date" but is still quite useful and powerful, so is shell scripting, and UDP for that matter)

Ideally the high-level system abstract design is based on business rules and not on the front-end/back-end technologies. The tiers should be populated with functionality in such a way as to minimize dependencies, and isolate functionalities in a coherent manner - knowing that everything is likely to change, and changes should be made in the fewest number of places, and be testable.
\end{obecne}
