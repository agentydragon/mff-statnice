\subsection{Indexy, triggery, uloené procedury, uivatelé}

TODO: poøádná definice indexu

\begin{obecne}{Index}
Index je obvykle definován vıbìrem tabulky a jejího konkrétního sloupce (nebo sloupcù), nad kterımi si designér databáze pøeje dotazování urychlit; dále pak technickım urèením typu. Chování a zpùsoby uloení indexù se mohou vıznamnì lišit podle pouité databázové technologie.
Vıjimku mohou tvoøit napøíklad full-textové indexy, které jsou v nìkterıch pøípadech (nerelaèní databáze typu Lotus Notes) definovány nad celou databází, nikoliv nad konkrétní tabulkou. 
\end{obecne}

\begin{obecne}{Pouití indexu}
Na první pohled by se mohlo zdát, e èím víc indexù, tím lepší chování databáze a e po vytvoøení indexù pro všechny sloupce všech tabulkách dosáhneme maximálního zrychlení. Tento pøístup naráí bohuel na dva zásadní problémy: 
\begin{penumerate}
    \item Kadı index zabírá v pamìti vyhrazené pro databázi nezanedbatelné mnoství místa (vzhledem k pamìti vyhrazené pro tabulku). Pøi existenci mnoha indexù se mùe stát, e pamì zabraná pro jejich chod je skoro stejnì velká, jako pamì zabraná jejími daty - zvláštì u rozsáhlıch tabulek (typu faktovıch tabulek v datovém skladu) mùe nìco takového bıt nepøijatelné. 
    \item Kadı index zpomaluje operace, které mìní obsah indexovanıch sloupcù (napøíklad SQL pøíkazy UPDATE, INSERT). To je dáno tím, e databáze se v pøípadì takové operace nad indexovanım sloupcem musí postarat nejen o zmìny v datech tabulky, ale i o zmìny v datech indexu. 
\end{penumerate}
\end{obecne}

\begin{obecne}{Typy indexù}
Indexy mohou mít svùj typ, kterı blíe urèuje, jakım zpùsobem má bıt pøistupování k datùm tabulky optimalizováno. Oznaèení se rùzní, ale nejèastìji je to:
\begin{pitemize}
    \item PRIMARY - Tento typ se v kadé tabulce mùe vyskytovat nejvıše jednou. Definuje sloupec tabulky, kterı svou hodnotou jednoznaènì identifikuje záznam. Ve vìtšinì pøípadù se dodruje konvence takovı sloupec nazvat ID a jeho datovı typ stanovit jako celé èíslo (není-li potøeba jinak). Databázovı server by mìl bıt schopen nedopustit, aby byla do sloupce, k nìmu se tento typ indexu vztahuje, byla vloena hodnota, která ji v tabulce existuje (vìtšinou takovı pokus konèí chybovou hláškou). 
    \item UNIQUE - Tento typ je podobnı PRIMARY co do jednoznaènosti záznamu v tabulce (jak naznaèuje i jeho název) a dopadu, kterı to na práci s databází má; ale mùe se vyskytovat u více sloupcù tabulky. Podle úèelu, ke kterému má tabulka slouit, se obèas definují indexy sloené z více sloupcù - potom opìt nelze vloit záznam, kterı by ji v této kombinaci nìkde v tabulce existoval. 
    \item INDEX - Definicí indexu tohoto typu je v tabulce zajištìna optimalizace vyhledávání podle sloupce, ke kterému se danı index váe. Vìtšinou si databázovı server vytvoøí a nadále udruje vnitøní seznam odkazù na øádky tabulky, seøazenı podle hodnot sloupce, k nìmu se váe. Udrování takto seøazené posloupnosti urychluje vyhledávání (je mono pouít nìkteré interpolaèní numerické metody), øazení i jiné zásahy do tabulky, které jsou omezeny podmínkou na dotyèné záznamy. 
    \item FULL-TEXT - Vytvoøením tohoto indexu se databázovı server bude snait optimalizovat full-textové vyhledávání v daném sloupci u dané tabulky.
\end{pitemize}
\end{obecne}

\begin{obecne}{Triggery}
  Databázovı trigger je programovı kód, kterı je automaticky vykonán jako
  reakce na nìjakou událost v urèité databázové tabulce. Triggery mohou omezit
  pøístup k urèitım datùm, provádìt logování, nebo kontrolovat zmìny dat.

  Rozlišujeme dvì hlavní tøídy triggerù a to \emph{øádkovı trigger} a
  \emph{dotazovı (statement) trigger}. Øádkovı trigger mùeme definovat pro
  kadı øádek tabulky, zatímco dotazovı trigger se vykoná pouze jednou pro
  konkrétní databázovı dotaz. Kadá tøída triggerù mùe bıt nìkolika typù. Jsou
  \emph{before triggers} a \emph{after triggers}, co znaèí kdy má bıt trigger
  vykonán. Také se mùeme setkat s \emph{instead of triggers}, kterı je potom
  vykonán \emph{místo} dotazu kterım byl spuštìn. 

  Jaké události mohou trigger spustit se pochopitelnì liší databázovı systém od
  systému, ale existují tøi typické události, které to mohou bıt:
  \begin{penumerate}
    \item INSERT~-- novı záznam je vloen do databáze,
    \item UPDATE~-- záznam je mìnìn,
    \item DELETE~-- záznam je mazán.
  \end{penumerate}
  Kromì tìchto typickıch událostí mùe databázovı systém umoòovat nastavovat
  triggery také na mazání, èi vytváøení celıch tabulek, èi dokonce pøihlášení
  nebo odhlášení uivatele.

  Hlavní vlastnosti a efekty databázovıch triggerù jsou:
  \begin{pitemize}
    \item nepøijímají ádné parametry nebo argumenty,
    \item nemohou volat operace pro øízení transakcí COMMIT a ROLLBACK,
    \item mají pøístup k datùm, které budou mìnìny, je tedy moné vykonávat akce
    na základì nich,
    \item nemohou vracet záznamy,
    \item obtínì se ladí,
    \item mnoho triggerù nebo sloité triggery mohou práci s databází velice
    zpomalit a navíc znepøehlednit.
  \end{pitemize}
\end{obecne}

\begin{obecne}{K èemu triggery pouívat?}
  Triggery se v databázích pouívají z nìkolika dùvodù, které mohou souviset s
  konzistencí dat, jejich údrbou, nebo mohou bıt zpùsob, kterım databáze
  komunikuje s okolím. Podívejme se na nìkterá typická schémata:
  \begin{pitemize}
    \item \textbf{Konzistence dat}~-- Trigger mùe provést vıpoèet a na základì
    toho povolit nebo nepovolit zmìnu dat v databázi. Napøíklad trigger mùe zakázat
    smazání zákazníka z databáze v pøípadì, kdy má u nás nìjakı dluh a podobnì.  
    \item \textbf{Logování}~-- Trigger mùe evidovat kdo, kdy a jak mìnil data.
    Lze tak dohledat pracovníka, kterı zadal špatné údaje nebo zjistit, v kolik
    hodin došlo k vèerejší uzávìrce.
    \item \textbf{Verzování dat}~-- Díky triggerùm lze snadno naprogramovat
    aplikaci tak, aby jedna tabulka udrovala historii zmìn tabulky jiné. To lze
    s úspìchem pouít tøeba jako bezpeènostní mechanismus. 
    \item \textbf{Zasílání zpráv}~-- Trigger mùe spustit nìjakı externí
    program nebo proces. Napøíklad mùe trigger autorovi poslat e-mail,
    pokud byl k jeho èlánku pøidán pøíspìvek.
  \end{pitemize}
\end{obecne}

\begin{obecne}{Uloené procedury}
  Uloená procedura (anglicky stored procedure) je databázovı objekt, kterı
  neobsahuje data, ale èást programu, kterı se nad daty v databázi má vykonávat.

  Uloená procedura je pøedevším procedura. Jedná se o èást programu, kterı je
  (nebo by aspoò mìl bıt) jasnì funkènì oddìlenı od svého okolí, má interface
  (seznam parametrù) pro komunikaci s jinımi moduly programu. Mùe mít vlastní
  lokální promìnné neviditelné pro ostatní èásti programu. 

  Uloená procedura je uloená (rozumìj: uloená v databázi). To znamená, e se k
  ní lze chovat stejnì jako ke kadému jinému objektu databáze (indexu, pohledu,
  triggeru apod.). Lze jí zaloit, upravovat a smazat pomocí pøíkazù dotazovacího
  jazyka databáze (v pøípadì relaèní databáze obvykle pomocí pøíkazù DDL SQL). 

  Pro psaní uloenıch procedur je obvykle pouíván specifickı jazyk konkrétní
  databáze, kterı je rozšíøením jejího dotazovacího jazyka (hezkım pøíkladem je
  databáze Oracle s procedurálním jazykem PL/SQL, kterı je rozšíøením klasického
  dotazovacího jazyka SQL).
\end{obecne}

\begin{obecne}{Proè ukládat procedury?}
  \begin{pitemize}
      \item \textbf{Jednotné rozhraní}~-- Pouití uloenıch procedur vychází z
      faktu, e vìtšina operací nad daty v databázi probíhá stejnì bez ohledu na
      to, kdo operaci provádí. Pøíklad: Pokud je tøeba uloit do tabulky
      zákazníkù nového zákazníka, tak se to z pohledu databáze dìje stejnì pro
      zákazníka internetového obchodu, pro zákazníka, kterého zadává pracovnice
      telefonického centra pøes formuláø programu napsaného napøíklad v C++ ,
      nebo pro zákazníky, kteøí jsou vkládáni automaticky na základì textového
      reportu, kterı pøijde kadı den z \uv{kamennıch} prodejních míst a je
      zpracováván pomocí programu napsaného v PowerBuilderu. Je tedy celkem
      dobrı dùvod, aby existovala uloená procedura \uv{Zapiš nového zákazníka},
      kterou by mohly volat všechny tøi vıše uvedené aplikace - alternativou bez
      uloené procedury by bylo, e bych podobnou proceduru musel napsat ve
      tøech verzích - jednou v C++, jednou v Power Builderu a jednou v rámci
      programu pro internetovı obchod (tøeba ASP nebo PHP). 
      \item \textbf{Skrytí datovıch operací}~-- Druhou vıhodou pouití uloenıch
      procedur je, e se nemusím (v programu na \uv{klientské} stranì) zabıvat
      tím, jak jsou data uloena v konkrétních tabulkách. V našem pøípadì je mi
      jedno, jak si databáze uvnitø pamatuje zákazníky - prostì zadám jako
      parametr procedury jméno, pøíjmení, èíslo kreditky a co si zákazník koupil
      - a databáze (resp. její uloená procedura) si to nìjak pøebere. Uloené
      procedury se v pøípadì databázovıch aplikací staly základním kamenem pro
      realizaci architektury klient/server, kdy je na jedné stranì (klientská
      èást) realizována v bìném procedurálním programovacím jazyku komunikace s
      uivatelem (formuláøe nebo tøeba webové stránky) a na druhé stranì
      (serverová èást) je pomocí uloenıch procedur realizována správa dat v
      relaèní databázi. Obì èásti (klientská a serverová) mezi sebou komunikují
      pøes co nejjednodušší rozhraní - voláním uloenıch procedur. 
  \end{pitemize}
\end{obecne}

TODO: uivatelé
