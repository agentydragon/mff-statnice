\subsection{Neprocedurální programování, logické programování}

\subsubsection*{Neprocedurální programování}
\emph{Deklarativní programování} je postaveno na paradigmatu, podle nìho je program zaloen na tom, co se poèítá a ne jak se to poèítá. Je zde deklarován vstup a vıstup a celı program je chápán jako funkce vyhodnocující vstupy podávající jedinı vıstup. Napøíklad i webovské stránky jsou deklarativní protoe popisují, jak by stránka mìla vypadat -- titulek, font, text a obrázky -- ale nepopisují, jak konkrétnì zobrazit stránky na obrazovce.

\emph{Logické programování} a \emph{funkcionální programování} jsou poddruhy deklarativního programování. Logické programování vyuívá programování zaloené na vyhodnocování vzorù - tvrzení a cílù. Klasickım zástupcem jazyka pro podporu tohoto stylu je Prolog.

Tento pøístup patøí pod deklarativní programování stejnì jako funkcionální programování, nebo deklaruje, co je vstupem a co vıstupem, a nezabıvá se jak vıpoèet probíhá. Naopak program jako posloupnost pøíkazù je paradigma imperativní.

\emph{Funkcionální programování} patøí mezi deklarativní programovací principy.

Alonzo Church vytvoøil formální vıpoètovı model nazvanı $\lambda$-kalkul. Tento model slouí jako základ pro funkcionální jazyky. Funkcionální jazyky dìlíme na:
\begin{pitemize}
	\item typované - Haskell
	\item netypované - Lisp, Scheme
\end{pitemize}

Vıpoètem funkcionálního programu je posloupnost vzájemnì ekvivalentních vırazù, které se postupnì zjednodušují. Vısledkem vıpoètu je vıraz v normální formì, tedy dále nezjednodušitelnı. Program je chápán jako jedna funkce obsahující vstupní parametry mající jedinı vıstup. Tato funkce pak mùe bıt dále rozloitelná na podfunkce.

\subsubsection*{Prolog}

Prolog je logickı programovací jazyk. Název Prolog pochází z francouzského programmation en logique (\uv{logické programování}). Byl vytvoøen Alainem Colmerauerem v roce 1972 jako pokus vytvoøit programovací jazyk, kterı by umoòoval vyjadøování v logice místo psaní poèítaèovıch instrukcí. Prolog patøí mezi tzv. deklarativní programovací jazyky, ve kterıch programátor popisuje pouze cíl vıpoètu, pøièem pøesnı postup, jakım se k vısledku program dostane, je ponechán na libovùli systému.

Prolog je vyuíván pøedevším v oboru umìlé inteligence a v poèítaèové lingvistice (obzvláštì zpracování pøirozeného jazyka, pro nìj byl pùvodnì navren). Syntaxe jazyka je velice jednoduchá a snadno pouitelná pravì proto, e byl pùvodnì urèen pro poèítaèovì nepøíliš gramotné lingvisty.

Prolog je zaloen na \emph{predikátové logice prvního øádu} (konkrétnì se omezuje na Hornovy klauzule). Bìh programu je pak pøedstavován aplikací dokazovacích technik na zadané klauzule. Základními vyuívanımi pøístupy jsou \emph{unifikace}, \emph{rekurze} a \emph{backtracking}.

Interpret Prologu se snaí nalézt nejobecnìjší substituci, která splní danı cíl - tzn. nesubstituuje zbyteènì, pokud nemusí (pouití interních promìnnıch -- \_123 atd.). Za dvì promìnné mùe bıt substituována jedna interní promìnná (napø. pøi hledání svislé úseèky -- konstantní X souøadnice) -- tomu se øíká \emph{unifikace} promìnnıch. Pro promìnnou, její hodnota mùe bıt libovolná, se v prologu uívá znak \uv{\_}. 

Datové typy v prologu se nazıvají \emph{termy}. Základním datovım typem jsou \emph{atomy} (zaèínají malım písmenem, nebo se skládají ze speciálních znakù (\texttt{+ - * / \dots}, nebo jsou to znakové øetìzce (\texttt{'text'})). Dále \uv{jsou} v prologu èísla (v komerèních implementacích i reálná), promìnné (velké písmeno) a struktury (definované rekursivnì - pomocí funktoru dané arity a pøíslušnım poètem termù, které jsou jeho argumenty -- \texttt{okamzik(datum(1,1,1999),cas(10,10))}). Posledním typem promìnnıch jsou seznamy, které jsou probírány pozdìji.

\medskip\textbf{Základní principy}:

Programování v Prologu se vıraznì liší od programování v bìnıch procedurálních jazycích jako napø. C. Program v prologu je databáze faktù a pravidel (dohromady se faktùm a pravidlùm paradoxnì øíká procedury), nad kterımi je mono klást dotazy formou tvrzení, u kterıch Prolog zhodnocuje jejich pravdivost (dokazatelnost z údajù obsaenıch v databázi).

Napøíklad lze do databáze uloit fakt, e Monika je dívka:
\begin{verbatim}
dívka(monika).
\end{verbatim}

Poté lze dokazatelnost tohoto faktu provìøit otázkou, na kterou Prolog odpoví yes (ano):
\begin{verbatim}
?- dívka(monika).
     yes.
\end{verbatim}

Také se lze zeptat na všechny objekty, o kterıch je známo, e jsou dívky (støedníkem poadujeme další vısledky):
\begin{verbatim}
?- dívka(X).
     X = monika;
     no.
\end{verbatim}

Pravidla (závislosti) se zapisují pomocí implikací, napø.
\begin{verbatim}
syn(A,B) :- rodiè(B,A), mu(A).
\end{verbatim}

Tedy: pokud B je rodièem A a zároveò je A mu, pak A je synem B. První èásti pravidla (tj. dùsledku) se øíká hlava a všemu co následuje za symbolem \texttt{:-} (tedy podmínkám, nutnım pro splnìní hlavy) se øíká tìlo. Podmínky ke splnìní mohou bıt oddìleny buï èárkou (pak jde o konjunkci, musejí bıt splnìny všechny), nebo støedníkem (disjunkce), pøièem èárky mají vìtší prioritu.

\medskip\textbf{Pøíklad}:

Typickou ukázkou základù programování v Prologu jsou rodinné vztahy.
\begin{verbatim}
sourozenec(X,Y) :- rodiè(Z,X), rodiè(Z,Y).
rodiè(X,Y) :- otec(X,Y).
rodiè(X,Y) :- matka(X,Y).
mu(X) :- otec(X,_).
ena(X) :- matka(X,_).
matka(marie,monika).
otec(jiøí,monika).
otec(jiøí,marek).
otec(michal,tomáš).
\end{verbatim}

Prázdnı seznam je oznaèen atomem $[]$, neprázdnı se tvoøí pomocí funktoru \texttt{'.'} (teèka) - \texttt{.(Hlava,Tìlo)}. V praxi se to (naštìstí ;-)) takhle sloitì rekurzivnì zapisovat nemusí, staèí napsat \texttt{[a,b,c...]}, resp \texttt{[Zaèátek | Tìlo]}, kde zaèátek je vıèet prvkù (ne seznam) stojících na zaèátku definovaného seznamu, a tìlo je (rekurzivnì) seznam (napø. \texttt{[a,b,c|[]]}).

Aritmetické vırazy se samy o sobì nevyhodnocují, dokud jim to nìkdo nepøikáe. Take napø. predikát \texttt{5*1 = 5} by selhal. Vyhodnocení se vynucuje pomocí operátoru \emph{is} (pomocí = by došlo jen k unifikaci) - není to ale ekvivalent \uv{\texttt{=}} z jinıch jazykù. Tento operátor se musí pouít na nìjakou volnou promìnnou a aritmetickı vıraz, s jeho hodnotou bude tato promìnná dále svázaná (jako napø. \texttt{X is 5*1,X=5} uspìje).

Dùleitı je i \emph{operátor øezu} (znaèíme vykøièníkem). Tento predikát okamitì uspìje, ale pøi tom zakáe backtrackování pøes sebe zpìt. (\texttt{prvek1(X,[X|L]):-!. prvek1(X,[\_|L]):-prvek1(X,L).} - je-li prvek nalezen, je zakázán návrat = najde jen první vıskyt prvku). Dále je dùleitá negace (\texttt{not(P):- P, !, fail. not(P).} -- uspìje, pokud se nepodaøí cíl P splnit). Øez tedy umoòuje ovlivòovat efektivitu prologovskıch programù, definovat vzájemnì se vyluèující pouití jednotlivıch klauzulí procedury, definovat negaci atd.

\subsubsection*{Haskell}
Haskell je standardizovanı funkcionální programovací jazyk pouívající zkrácené vyhodnocování, pojmenovanı na poèest logika Haskella Curryho. Byl vytvoøen v 80. letech 20. století. Posledním polooficiálním standardem je Haskell 98, kterı definuje minimální a pøenositelnou verzi jazyka vyuitelnou k vıuce nebo jako základ dalších rozšíøení. Jazyk se rychle vyvíjí, pøedevším díky svım implementacím Hugs a GHC (viz níe).

Haskell je jazyk dodrující \emph{referenèní transparentnost}. To, zjednodušenì øeèeno, znamená, e tentı (pod)vıraz má na jakémkoliv místì v programu stejnou hodnotu. Mezi další vıhody tohoto jazyka patøí pøísné \emph{typování promìnnıch}, které programátorovi mùe usnadnit odhalování chyb v programu. Haskell plnì podporuje práci se soubory i standardními vstupy a vıstupy, která je ale pomìrnì sloitá kvùli zachování referenèní transparentnosti. Jako takovı se Haskell hodí hlavnì pro algoritmicky nároèné úlohy minimalizující interakci s uivatelem.

\medskip\textbf{Pøíklady}:

Definice funkce faktoriálu:
\begin{verbatim}
fac 0 = 1
fac n = n * fac (n - 1)
\end{verbatim}

Jiná definice faktoriálu (pouívá funkci product ze standardní knihovny Haskellu):
\begin{verbatim}
fac n = product [1..n]
\end{verbatim}

Naivní implementace funkce vracející n-tı prvek Fibonacciho posloupnosti:
\begin{verbatim}
fib 0 = 0 
fib 1 = 1 
fib n = fib (n - 2) + fib (n - 1)
\end{verbatim}

Elegantní zápis øadícího algoritmu quicksort:
\begin{verbatim}
qsort [] = []
qsort (pivot:tail) = 
  qsort left ++ [pivot] ++ qsort right
  where
    left = [y | y <- tail, y < pivot]
    right = [y | y <- tail, y >= pivot]
\end{verbatim}

TODO: popsat stráe (pøípady, otherwise), seznamy, øetìzení, pattern matching u parametrù funkcí, lok. definice (where, let) -- patøí to sem?

\subsubsection*{Lisp}

Lisp je funkcionální programovací jazyk s dlouhou historií. Jeho název je zkratka pro List processing (zpracování seznamù). Dnes se stále pouívá v oboru umìlé inteligence. Nic ale nebrání ho pouít i pro jiné úèely. Pouívá ho napøíklad textovı editor Emacs, GIMP èi konstrukèní program AutoCAD.

Další jazyky od nìj odvozené jsou napøíklad Tcl, Smalltalk nebo Scheme.


\medskip\textbf{Syntaxe}:
Nejzákladnìjším zápisem v Lispu je seznam. Zapisujeme ho jako:
\begin{verbatim}
(1 2 "ahoj" 13.2)
\end{verbatim}

Tento seznam obsahuje ètyøi prvky:
\begin{pitemize}
	\item celé èíslo 1
	\item celé èíslo 2
	\item text \uv{ahoj}
	\item reálné èíslo 13,2
\end{pitemize}

Jde tedy o uspoøádanou ètveøici. Všimnìte si, e závorky nefungují tak jako v matematice, ale pouze oznaèují zaèátek a konec seznamu. Seznamy jsou v Lispu implementovány jako binární strom degenerovanı na jednosmìrnì vázanı seznam. Co se seznamem Lisp udìlá, záleí na okolnostech.

\textbf{Pøíkazy}: Pøíkazy píšeme také jako seznam, první prvek seznamu je však název pøíkazu. Napøíklad sèítání provádíme pøíkazem +, co interpreteru zadáme takto:
\begin{verbatim}
(+ 1 2 3)
\end{verbatim}
Interpretr odpoví 6.

\textbf{Ukázka kódu}:
Program hello world lze zapsat nìkolika zpùsoby. Nejjednoduší vypadá takto:
\begin{verbatim}
(format t "Hello, World!")
\end{verbatim}

Funkce se v Lispu definují pomocí klíèového slova defun:
\begin{verbatim}
(defun hello ()
        (format t "Hello, World!")
)
(hello)
\end{verbatim}

Na prvních dvou øádcích je definice funkce hello, na tøetím øádku je tato funkce svım jménem zavolána.
Funkcím lze pøedávat i argumenty. V následujícím pøíkladu je ukázka funkce fact, která vypoèítá faktoriál zadaného èísla:
\begin{verbatim}
(defun fact (n)
        (if (= n 0)
                1
                (* n (fact (- n 1)))
        )
)
\end{verbatim}
Pro vıpoèet faktoriálu èísla 6 pøedáme tuto hodnotu jako argument funkci fact:
\begin{verbatim}
(fact 6)
\end{verbatim}
Návratovou hodnotou funkce bude hodnota 720.

\subsubsection*{Logické programování}
TODO (není souèástí otázek pro obor Programování)
